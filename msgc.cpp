#ifndef _MAKE_MSGC_msgc_cpp_ID_
#define _MAKE_MSGC_msgc_cpp_ID_
#if defined(__sgi) && defined(_SGI_COMPILER_VERSION)
#pragma weak _MAKE_MSGC_msgc_cpp_id_w = _MAKE_MSGC_msgc_cpp_id_
#endif /* __sgi */
static const char* _MAKE_MSGC_msgc_cpp_id_ 
#if defined(__GNUC__)
__attribute__ ((used,unused)) 
#endif /* __GNUC__ */
= "@(#)$Id: msgc.cpp 55141 2009-08-18 21:17:30Z wguan@syncsort.com $";
#endif

/******************************************************************************

                      Syncsort CLIENT-SERVER BACKUP

                            COPYRIGHT(C) 2000

        Module Name             : msgc

        Component Name          : DevTools

        Program Filename        : msgc.cpp

        General Description     : Message Compiler

        System Dependencies     : NONE

        History Information     : Provided by the RCS package in the following.

 * $Log: msgc.cpp,v $
 * Revision 1.38  2008/04/23 16:22:24  raghu
 * I..5-090: Bug 2025: Do not throw an exception when null request mdata is passed to java client stub functions.
 *
 * Revision 1.37  2008/04/15 19:50:14  raghu
 * I..5-090: Bug 2025: Throw NullPointerException if a null request mdata is passed to java client stubs
 *
 * Revision 1.36  2007/08/30 15:19:53  raghu
 * I..4-804: The static variables "toksAll" and "funcMap" in auto-generated SvcProvider_*.java files should be initialized with static initializers. I also ported Ted's earlier change (adding TIME_X as new PrimType).
 *
 * Revision 1.35  2006/11/06 22:22:56  urano
 * I..4-204: msgc: verstr directive
 *
 * Revision 1.34  2006/09/28 20:34:45  urano
 * I..3-477: message compatibility checking infrastructure
 *
 * Revision 1.33  2006/09/28 16:54:54  urano
 * I..3-477: getFuncMap
 *
 * Revision 1.32  2005/12/14 22:08:05  urano
 * I..3-477: listToks
 *
 * Revision 1.31  2005/03/14 20:52:20  urano
 * I..2-820: BEXIDL: hidden qualifier for a mdata member
 *
 * Revision 1.30  2004/02/09 16:14:13  urano
 * I..1-917: BEXIDL : clear cache between 'translation units'
 *
 * Revision 1.29  2004/01/26 21:27:16  urano
 * I..1-584: SvcProvider class to handle bexException being thrown with CtlMDat embedded
 *
 * Revision 1.28  2003/08/05 16:52:46  urano
 * I..1-484: dev fixes
 *
 * Revision 1.27  2003/07/23 16:11:34  urano
 * I..1-658: msgc JAVA stub to synchronize
 *
 * Revision 1.26  2003/07/21 20:43:54  urano
 * I..1-658: msgc JAVA stub to synchronize
 *
 * Revision 1.25  2003/05/22 13:07:48  urano
 * I...-674: Device Management Module
 *
 * Revision 1.24  2003/05/14 17:56:31  urano
 * I..1-613: BEXIDL : format specification for mdata
 *
 * Revision 1.23  2003/05/06 20:10:18  urano
 * I..1-613: BEXIDL : format specification for mdata
 *
 * Revision 1.22  2003/04/11 14:25:31  urano
 * I..1-584: bexException to keep ctlMDat; SvcInt_X in Java
 *
 * Revision 1.21  2003/02/11 17:17:49  urano
 * I..1-460: Moving constants into BEXIDL
 *
 * Revision 1.20  2003/01/30 22:17:28  urano
 * I...-659: syntax error in autogenerated JAVA file
 *
 * Revision 1.19  2003/01/15 18:49:35  urano
 * I..1-412: Improving compile time for BEXIDL C++ stubs
 *
 * Revision 1.18  2003/01/08 18:27:36  urano
 * I...-666: rstring_sy
 *
 * Revision 1.17  2002/11/25 20:45:28  urano
 * I..1-436: devui
 *
 * Revision 1.16  2002/11/25 17:17:07  urano
 * I..1-450: exit status
 *
 * Revision 1.15  2002/11/15 20:10:32  urano
 * I..1-436: devui
 *
 * Revision 1.14  2002/11/14 21:43:26  urano
 * I..1-436: devui
 *
 * Revision 1.13  2002/11/11 14:54:35  urano
 * I..1-412: Improving compile time for BEXIDL C++ stubs
 *
 * Revision 1.12  2002/11/06 22:25:26  urano
 * I..1-412: Improving compile time for BEXIDL C++ stubs
 *
 * Revision 1.11  2002/10/10 22:07:35  urano
 * I...-674: winnt compatibility
 *
 * Revision 1.10  2002/10/10 19:35:31  urano
 * I..1-375: link does not imply inner
 *
 * Revision 1.9  2002/10/08 14:19:00  urano
 * I...-674: Device Management Module
 *
 * Revision 1.8  2002/09/11 18:16:41  urano
 * I...-674: Device Management Module
 *
 * Revision 1.7  2002/07/23 21:14:11  urano
 * I...-674: Device Management Module
 *
 * Revision 1.6  2002/06/12 19:41:28  urano
 * I..1-124: Device Management Module
 *
 * Revision 1.5  2001/10/23 16:18:58  urano
 * I..1-079: stree: purify stree_get_next... interface
 *
 * Revision 1.4  2001/10/22 15:11:49  urano
 * I..1-079: mdat_stree_put/get uses mdata name if passed NULL
 *
 * Revision 1.3  2001/10/01 20:10:45  urano
 * I..1-080: msgc/Java allow request data to be NULL in svc interface - startwatch() problem
 *
 * Revision 1.2  2001/09/28 21:29:35  urano
 * I..1-069: msg_flag autogeneration in msgc
 *
 * Revision 1.1  2001/09/20 16:33:55  urano
 * Initial revision
 *
 *
*****************************************************************************/

#include <msgc.hpp>

// stdlib includes
#include <ctype.h>  // for toupper
#include <algorithm>
//using std::for_each;
using std::transform;
#include <exception>
//#include <functional>
//using std::mem_fun_ref;
#include <fstream>
using std::endl;
using std::ifstream;
using std::ofstream;
#include <iomanip>
using std::setfill;
using std::setw;
// #include <locale>
#include <strstream>
using std::istrstream;
using std::ostrstream;
#include <stdexcept>
using std::logic_error;

// genlib includes
#include <cmdline.hpp>
#include <filename.hpp>
using gen::NativeFileName;


#ifdef YYDEBUG
extern int yydebug;
#endif

// for the case that the C++ compiler does not handle const static objects properly...
const std::string TCharSy::NAME = "tchar_sy";
const std::string BCharSy::NAME = "bchar_sy";
const std::string CCharSy::NAME = "cchar_sy";
const std::string RCharSy::NAME = "rchar_sy";

const std::string MDataTypeInfo::STR_NEXT = "next"; // variable name used for link mdata's pointer to itself
const std::string MDataTypeInfo::STR_REQID = "reqid"; // variable name used for request id

// static stores
stringPtrMap<DataTypeInfo::Ptr> DataTypeInfo::store;
stringPtrMap<PrimTypeInfo::Ptr> PrimTypeInfo::store;
stringPtrMap<UserDefinedTypeInfo::Ptr> UserDefinedTypeInfo::store;
stringPtrMap<FlagTypeInfo::Ptr> FlagTypeInfo::store;
stringPtrMap<MDataTypeInfo::Ptr> MDataTypeInfo::store;
stringPtrMap<SvcDef::Ptr> SvcDef::store;
stringPtrMap<EnvTypeInfo::Ptr> EnvTypeInfo::store;
stringPtrMap<SvrDef::Ptr> SvrDef::store;

class codeDelim {
  std::ostream &os;
  std::string name;
public:
  codeDelim (std::ostream & _os, const std::string & _name) : os(_os), name(_name) {
    os << "/* Begin " << name << " */\n";
  }
  ~codeDelim () {
    os << "/* End " << name << " */\n";
  }
};

class NativeJFile : public NativeFileName {
public:
  NativeJFile (const std::string & _fileName, const std::string & _dirName ) : NativeFileName (_fileName) {
    setDirectory (_dirName);
    setExtension ("java");
  }
};

class NativeInputFile : public NativeFileName {
public:
  NativeInputFile (const std::string & _fileName) : NativeFileName (_fileName) {}
};

bool operator< (const NativeInputFile & x, const NativeInputFile & y) {
  if (x.getExtension() == y.getExtension()) 
    return (x.getFullName() < y.getFullName());
  return (x.getExtension() < y.getExtension());
}

//
// KeywordTab implementations
//
std::map<std::string, int> KeywordTab::tab;
std::map<std::string, std::vector<std::string> > KeywordTab::classTab;

void KeywordTab::add (const std::string & _name, const std::string & _idName, 
		      const std::string & _className) {
  add (_name);
  classTab[_name].push_back(_className + "::info_" + _idName);
}

void KeywordTab::add (const std::string & _name, int _value) {
  static int value;
  if (done)
    throw msgc_exception("no new keywords can be added after the keyword table has been defined");
  if (_value==-1) {
    _value = ++value;
  } else if (_value) {
    value = _value;
  }
  if (tab[_name] && _value)
    throw msgc_exception("keyword (" + _name + ") already has value");
  tab[_name] = _value;
}

void KeywordTab::setDone () {
  done = true;
  std::set<int> usedNums;
  { // fill in usedNums, checking to make sure that there are no duplicate entries
    for (std::map<std::string, int>::iterator 
	   it = tab.begin(); it != tab.end(); ++it) {
      if (it->second) {
	if (usedNums.find(it->second) == usedNums.end())
	  usedNums.insert (it->second);
	else 
	  throw msgc_exception ("the value assigned to keyword " + it->first + " is already taken");
      }
    }
  }
  { // look for an opening (some range starting at an int mod 500) where we can
    // insert the extra keywords, where xx > 10
    const int rangeInit = 10000; // should not be zero
    const int rangeSize = 500;
    int neededSize = tab.size() - usedNums.size();
    if (neededSize < rangeSize) neededSize = rangeSize;
    for (int i = rangeInit; i < 32767; i += rangeSize)
      if (usedNums.lower_bound(i) == usedNums.upper_bound(i+neededSize-1)) {
	insertSlot = i;
	break;
      }
    if (0 == insertSlot) 
      throw msgc_exception ("Could not find a range to insert extra keywords in keyword_tab.");
  }
}

void KeywordTab::printCDeclaration (std::ostream & os) const {
  os << "typedef enum keyword_t {\n";
  bool firstEntry = true;
  for (std::map<std::string, int>::iterator 
	 it = tab.begin(); it != tab.end(); ++it) {
    if (it->second) {
      if (firstEntry) firstEntry = false;
      else os << ",\n";
      os << "  " << it->first << " = " << it->second;
    }
  }
  os << "\n  /* keywords not found in keyword_tab (if any) are listed below */";
  int i = insertSlot;
  for (std::map<std::string, int>::iterator 
	 it = tab.begin(); it != tab.end(); ++it) {
    if (!it->second) {
      if (firstEntry) firstEntry = false;
      else os << ",\n";
      os << "  " << it->first << " = " << i++;
    }
  }
  os << "\n} KEYWORD_T;\n";
}

void KeywordTab::printCPPDeclaration (std::ostream & os) const {
}

void KeywordTab::printCDefinition (std::ostream & os) const {
}
 
void KeywordTab::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for keyword tab");
  os << "#include <ms_toks.h>\n";
  os << "namespace gen {\n";
  os << "void TokInfo::initialize () {\n";
  for (std::map<std::string, int>::iterator 
	 it = tab.begin(); it != tab.end(); ++it) {
    std::vector<std::string> infoNams = classTab[it->first];
    for (std::size_t i=0; i<infoNams.size(); i++) 
      os << "  setInfo(" << it->first << ", " << infoNams[i] << ");\n";
  }
  os << "}\n";
  os << "}\n";
}
 
void KeywordTab::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os)
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n";
  os << '\n';

  codeDelim _cd(os, "Java Definition for " + getJName());
  os << '\n';

  // begin keyword class definition
  os << "public final class " << getJName() << " {\n";
  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  for (std::map<std::string, int>::iterator 
	 it = tab.begin(); it != tab.end(); ++it) {
    if (it->second) {
      os << "public final static short " << it->first << " = (short) " << it->second << ";\n";
    }
  }
  os << "  // keywords not found in keyword_tab (if any) are listed below \n";
  int i = insertSlot;
  for (std::map<std::string, int>::iterator 
	 it = tab.begin(); it != tab.end(); ++it) {
    if (!it->second) {
      os << "public final static short " << it->first << " = " << i++ << ";\n";
    }
  }
  os << "}\n";
}


//
// FlagTypeInfo implementations
//
 
void FlagTypeInfo::printCDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C Declaration for flag " + getName());
}

void FlagTypeInfo::printCPPDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C++ Declaration for flag " + getName());
}

void FlagTypeInfo::printCDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C Definition for flag " + getName());
}

void FlagTypeInfo::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for flag " + getName());
}

void FlagTypeInfo::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os) 
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");
  codeDelim _cd(os, "Java Definition for flag " + getName());
}

//
// MDataMemberInfo implementations
//
MDataMemberInfo::MDataMemberInfo (const std::string & _name, int _isConst, int _isHidden,
				  const std::string & _typeName, const std::vector<TypeQualifier> & _typeQuals, 
				  const std::string & _defVal, const MDataVisualInfo & _visInfo, 
				  const std::vector<std::string> & _comments) : 
  NamedObject (_name), b_IsConst (_isConst), b_IsHidden (_isHidden), typeQuals(_typeQuals), defVal(_defVal), 
  visInfo(_visInfo), comments(_comments) {
  typePtr = DataTypeInfo::get (_typeName);
  int defLenNameCount =0; 
  for (std::vector<TypeQualifier>::size_type i=0; i<typeQuals.size(); i++)
    {
      // check and set default variable array size variable names
      if (typeQuals[i].isVarArray() && typeQuals[i].getLenName().empty()) 
	{
	  if (i==0 && !(typePtr->arrayNeedsLenVar()))
	    continue;
	  if (defLenNameCount++)
	    throw msgc_exception("multiple default size names were specified for "
				 "multi-dimensional variable length array, "
				 +_name+".");
	  typeQuals[i].setLenName(_name+"_len");
	}
      // check to see if specified memory handling is doable
      if (!typeQuals[i].b_ParserAllocatesMemory) 
	{
	  if (i > 1)
	    throw msgc_exception("2nd or higher level arrays and pointers "
				 "must allocate memory in the parser, for variable "
				 +_name+".");
	  if (typePtr->parserMustAllocateMemory())
	    throw msgc_exception("invalid memory handling spec for the data type " 
				 +typePtr->getName() +".");
	}
    }
}

// todo: not complete
std::string MDataMemberInfo::getCPPConstRef () const {
  std::string outType = typePtr->getCPPName();
  std::string outName = ""; 
  bool needTypeDef = false;
  
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (i == 1 && typeQuals[0].isPtr()) 
      {
	if (needTypeDef)
	  return std::string("TypeDef<") + outType + " " + outName + ">::type *";
	else
	  return outType + " " + outName + " *";
      }
    else if (typeQuals[i-1].isVarArray())
      {
	if (i==typeQuals.size()) 
	  outType = typePtr->getCPPArrayName();
	else
	  {
	    outType = "std::vector<" + outType + " " + outName +" >";
	    outName = "";
	    needTypeDef = false;
	  }
      }
    else if (typeQuals[i-1].isFixedArray())
      {
	outType = "std::vector<" + outType + " " + outName +" >";
	outName = "";
	needTypeDef = false;
//	outName ="("+ outName+")["+typeQuals[i-1].getMaxLenName()+"]";
//	needTypeDef = true;
      }
    else if (typeQuals[i-1].isPtr())
      {
	if (needTypeDef)
	  outName = "*(" + outName + ")";
	else
	  outName = "*" + outName;
      }

  if (needTypeDef)
    return "const TypeDef<" + outType + " " + outName + ">::type &";
  else
    return std::string("const ") + outType + " " + outName + " &";
}

// todo: not complete
std::string MDataMemberInfo::getCPPDefaultVal () const {
  if (typeQuals.size() && typeQuals[0].isPtr()) return "0";
  else
    return getCPPQualTypeName() + "(" + defVal + ")";
}

std::string MDataMemberInfo::getCPPQualTypeName () const {
  std::string outType = typePtr->getCPPName();
  std::string outName = ""; 
  bool needTypeDef = false;
  
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (typeQuals[i-1].isVarArray())
      {
	if (i==typeQuals.size()) 
	  outType = typePtr->getCPPArrayName();
	else
	  {
	    outType = "std::vector<" + outType + " " + outName +" >";
	    outName = "";
	    needTypeDef = false;
	  }
      }
    else if (typeQuals[i-1].isFixedArray())
      {
	    outType = "std::vector<" + outType + " " + outName +" >";
	    outName = "";
	    needTypeDef = false;
//	if (!outName.empty()) outName = "(" + outName + ")";
//	outName = outName+"["+typeQuals[i-1].getMaxLenName()+"]";
//	needTypeDef = true;
      }
    else if (typeQuals[i-1].isPtr())
      {
	if (needTypeDef && !outName.empty()) 
	  outName = "(" + outName + ")";
	outName = "*" + outName;
      }

  if (needTypeDef)
    return "TypeDef<" + outType + " " + outName + ">::type";
  else
    return outType + " " + outName;
}

std::string MDataMemberInfo::getJQualTypeName () const {
  std::string out = typePtr->getJName();
  for (std::vector<TypeQualifier>::size_type i = 0; i < typeQuals.size(); i++)
    if (typeQuals[i].isVarArray())
      {
	if (i==0) 
	  out = typePtr->getJArrayName();
	else
	  out = out + "[]";
	  // out = "Vector";
      }
    else if (typeQuals[i].isFixedArray())
      out = out + "[]";
    else if (typeQuals[i].isPtr())
      { // do nothing
      }

  return out;
}

std::string MDataMemberInfo::getLenNameAtLevel (std::vector<TypeQualifier>::size_type level) {
  std::vector<TypeQualifier>::size_type myLevel = 0;
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (typeQuals[i-1].isArray() && (++myLevel == level))
      return typeQuals[i-1].getLenName();
  return "";
}

std::string MDataMemberInfo::getMaxLenNameAtLevel (std::vector<TypeQualifier>::size_type level) {
  std::vector<TypeQualifier>::size_type myLevel = 0;
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (typeQuals[i-1].isArray() && (++myLevel == level))
      return typeQuals[i-1].getMaxLenName();
  return "";
}

void MDataMemberInfo::printDecOneLine (std::ostream & os, const std::string & _type, const std::string & _name) {
  // the string(...).c_str() strangeness below is a hack to get around 
  // incompatibility in g++ between the setw() manipulator and the string class.
  std::ios::fmtflags oldFlags = os.flags();
  os.setf(std::ios::right, std::ios::adjustfield);
  os << setw(20) << _type.c_str();
  os.setf(std::ios::left, std::ios::adjustfield);
  os << setw(30) << _name.c_str();
  os.flags(oldFlags);
}

void MDataMemberInfo::printDecDefine (std::ostream & os, const std::string & _name, const std::string & _value) {
  // the string(...).c_str() strangeness below is a hack to get around 
  // incompatibility in g++ between the setw() manipulator and the string class.
  std::ios::fmtflags oldFlags = os.flags();
  os << "#define ";
  os.setf(std::ios::left, std::ios::adjustfield);
  os << setw(40) << _name.c_str() << " " << _value;
  os.flags(oldFlags);
}

// fully qualified size variable name
std::string MDataMemberInfo::getSzName (const std::string & szNameBase, 
				     std::vector<TypeQualifier>::size_type level) const {
  int loopVarCount = 0;
  std::string arraySizeVarName = szNameBase;
  for (std::vector<TypeQualifier>::size_type k = typeQuals.size(); k>level; k--)
    {
      if (typeQuals[k-1].isArray())
	{
	  std::ostrstream tt; tt << "(" << arraySizeVarName << ")" << "[i_"<< loopVarCount++ << "]" << std::ends;
	  arraySizeVarName = tt.str(); tt.freeze(false);
	}
    }
  return arraySizeVarName;
}

std::ostream & MDataMemberInfo::indent (std::ostream & os, int indentCount) {
  for (int i=0; i<indentCount; i++) os << "  ";
  return os;
}

void MDataMemberInfo::printCTokPut (std::ostream & os, const std::string & buffPtrName, 
				    const std::string & buffEndPtrName, const std::string & structPtrName, 
				    int & loopVarCount, int & errCodeCount, 
				    const std::string & varName, std::vector<TypeQualifier>::size_type level) const {
  int indentCount = typeQuals.size()-level+1;
  if (level == 0)
    {
      // simply printout the tokPut for this type
      indent(os, indentCount) 
	<< "if ("
	<< typePtr->getCTokPut (buffPtrName, buffEndPtrName, varName)
	<< ") return (-" << errCodeCount++ << ");\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      indent(os, indentCount) 
	<< "if ("
	<< typePtr->getCArrayTokPut (buffPtrName, buffEndPtrName, varName, 
				     getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level))
	<< ") return (-" << errCodeCount++ << ");\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string linkPtrName = "_" + getName() + "_ptr";
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the tokPut for the size of the array
      indent(os, indentCount) 
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokPut (buffPtrName, buffEndPtrName, arraySizeVarName)
	<< ") return (-" << errCodeCount++ << ");\n";
      // initialize the link node pointer
      indent(os, indentCount) 
	<< linkPtrName << " = " << varName << ";\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level tokPut
      printCTokPut (os, buffPtrName, buffEndPtrName, structPtrName, 
		    ++loopVarCount, errCodeCount, 
		    "*("+linkPtrName+")", level-1);
      // print out the linking logic
      indent(os, indentCount+1) 
	<< linkPtrName << " = " << linkPtrName << "->" << typePtr->getLinkVar() << ";\n";
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // print out the switch on if this ptr points to something
      indent(os, indentCount)
	<< "if (" << varName << ") {\n";
      {
	// print out tokPut "1"
	indent(os, indentCount+1)
	  << "if ("
	  << DataTypeInfo::get("short_sy")->getCTokPut (buffPtrName, buffEndPtrName, "1")
	  << ") return (-" << errCodeCount++ << ");\n";
	// print out the next level tokPut
	printCTokPut (os, buffPtrName, buffEndPtrName, structPtrName, 
		      loopVarCount, errCodeCount, 
		      "*("+varName+")", level-1);
      }
      indent(os, indentCount)
	<< "} else {\n";
      {
	// print out tokPut "0"
	indent(os, indentCount+1)
	  << "if ("
	  << DataTypeInfo::get("short_sy")->getCTokPut (buffPtrName, buffEndPtrName, "0")
	  << ") return (-" << errCodeCount++ << ");\n";
      }
      indent(os, indentCount)
	<< "}\n";
    }
  else
    {
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the tokPut for the size of the array
      indent(os, indentCount) 
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokPut (buffPtrName, buffEndPtrName,arraySizeVarName)
	<< ") return (-" << errCodeCount++ << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level tokPut
      std::ostrstream tt; tt << "(" << varName << ")" << "[i_"<< loopVarCount << "]" << std::ends;
      printCTokPut (os, buffPtrName, buffEndPtrName, structPtrName, 
		    ++loopVarCount, errCodeCount, 
		    tt.str(), level-1);
      tt.freeze(false);
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
}

void MDataMemberInfo::printCTokGet (std::ostream & os, const std::string & buffPtrName, 
				    const std::string & memHndlName, const std::string & structPtrName, 
				    int & loopVarCount, int & errCodeCount,
				    std::vector<std::string> & usedLenNames, bool & useTmp,
				    const std::string & varName, std::vector<TypeQualifier>::size_type level) const {
  int indentCount = typeQuals.size()-level + 1;
  if (level == 0)
    {
      // simply printout the tokGet for this type
      indent(os, indentCount) 
	<< "if ("
	<< typePtr->getCTokGet (buffPtrName, memHndlName, varName)
	<< ") return (-" << errCodeCount++ << ");\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      std::string szName;
      if (typePtr->arrayNeedsLenVar()) szName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      else {szName = "tmp"; useTmp = true;};
      indent(os, indentCount) 
	<< "if ("
	<< typePtr->getCArrayTokGet (buffPtrName, memHndlName, varName, szName)
	<< ") return (-" << errCodeCount++ << ");\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the tokGet for the size of the array
      indent(os, indentCount) 
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokGet (buffPtrName, memHndlName, arraySizeVarName)
	<< ") return (-" << errCodeCount++ << ");\n";
      // print out the malloc for the linked array
      indent(os, indentCount) 
	<< "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" << varName << ", " 
	<< "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << arraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level tokGet
      printCTokGet (os, buffPtrName, memHndlName, structPtrName,
		    ++loopVarCount, errCodeCount, usedLenNames, useTmp,
		    "(" + varName + ")" + "[" + loopVar + "]", level-1);
      // print out the linking logic
      indent(os, indentCount+1) 
	<< "if (" << loopVar << ") " 
	<< "(" + varName + ")" + "[" + loopVar + "-1]." << typePtr->getLinkVar() << " = &("
	<< "(" + varName + ")" + "[" + loopVar + "]);\n";
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // we'll be using the "tmp" variable
      useTmp = true;
      // print out the tokGet to see if this Ptr points to something
      indent(os, indentCount)
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokGet (buffPtrName, memHndlName, "tmp")
	<< ") return (-" << errCodeCount++ << ");\n";
      // print out the switch on if this ptr points to something
      indent(os, indentCount)
	<< "if (tmp) {\n";
      {
	// print out the malloc for the ptr
	indent(os, indentCount+1) 
	  << "mdat_malloc_list (sizeof *" << varName << ", " 
	  << "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
	// print out the next level tokGet
	printCTokGet (os, buffPtrName, memHndlName, structPtrName,
		      loopVarCount, errCodeCount, usedLenNames, useTmp,
		      "*(" + varName + ")", level-1);
      }
      indent(os, indentCount)
	<< "} else {\n";
      {
	// set the var to NULL
	indent(os, indentCount+1)
	  << varName << " = NULL;\n";
	// if it's a pointer to an array, we need to zero the size of it as well
	if (level>=2 && typeQuals[level-2].isArray()) {
	  std::string lenName = typeQuals[level-2].getLenName();
	  if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
	    std::string szName = getSzName (structPtrName+"->"+lenName, level);
	    indent(os, indentCount+1)
	      << "  " << szName << " = 0;\n";
	  }
	}
      }
      indent(os, indentCount)
	<< "}\n";
    }
  else if (typeQuals[level-1].isVarArray())
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the tokGet for the size of the array
      indent(os, indentCount) 
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokGet (buffPtrName, memHndlName, arraySizeVarName)
	<< ") return (-" << errCodeCount++ << ");\n";
      // we're now sure that this lenName is fully malloc'ed
      usedLenNames.push_back (typeQuals[level-1].getLenName());
      // print out the malloc for the all the sub-array size variables as needed,
      for (std::vector<TypeQualifier>::size_type i = level-1; i>0; i-- )
	if (typeQuals[i-1].isArray()) 
	  {
	    // check to see if this sizeVar has already been malloc()'ed
	    std::vector<std::string>::size_type j;
	    for (j=0; j<usedLenNames.size(); j++)
	      if (typeQuals[i-1].getLenName() == usedLenNames[j]) break;
	    if (j == usedLenNames.size()) { // it's not, so print the malloc
              std::string lenName = typeQuals[i-1].getLenName();
              if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
		std::string szName = getSzName (structPtrName+"->"+lenName, level);
		indent(os, indentCount) 
		  << "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" 
		  << szName << ", " << "(void **) &("+szName+")" << ", " << memHndlName << ");\n";
	      }
	    }
	  }
      // print out the malloc for the var itself (at this level)
      indent(os, indentCount) 
	<< "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" << varName << ", " 
	<< "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << arraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level tokGet
      printCTokGet (os, buffPtrName, memHndlName, structPtrName,
		    ++loopVarCount, errCodeCount, usedLenNames, useTmp,
		    "(" + varName + ")" + "[" + loopVar + "]", level-1);
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
  else // (typeQuals[level-1].isFixedArray())
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the tokGet for the size of the array
      indent(os, indentCount) 
	<< "if ("
	<< DataTypeInfo::get ("short_sy")->getCTokGet (buffPtrName, memHndlName, arraySizeVarName)
	<< ") return (-" << errCodeCount++ << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << arraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level tokGet
      printCTokGet (os, buffPtrName, memHndlName, structPtrName,
		    ++loopVarCount, errCodeCount, usedLenNames, useTmp,
		    "(" + varName + ")" + "[" + loopVar + "]", level-1);
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }    
}

void MDataMemberInfo::printCCopy (std::ostream & os, 
				  const std::string & copyStructPtrName, const std::string & origStructPtrName, 
				  const std::string & memHndlName, 
				  int & loopVarCount, std::vector<std::string> & usedLenNames,
				  const std::string & copyVarName, const std::string & origVarName, 
				  std::vector<TypeQualifier>::size_type level) const {
  int indentCount = typeQuals.size()-level + 1;
  if (level == 0)
    {
      // simply printout the copy for this type
      indent(os, indentCount) 
	<< typePtr->getCCopy (copyVarName, origVarName, memHndlName) << ";\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      indent(os, indentCount) 
	<< typePtr->getCArrayCopy (copyVarName, origVarName, memHndlName,
				   getSzName (copyStructPtrName+"->"+typeQuals[level-1].getLenName(), level),
				   getSzName (origStructPtrName+"->"+typeQuals[level-1].getLenName(), level))
	<< ";\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string copyArraySizeVarName = getSzName (copyStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      std::string origArraySizeVarName = getSzName (origStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the Copy for the size of the array
      indent(os, indentCount) 
	<< DataTypeInfo::get ("short_sy")->getCCopy (copyArraySizeVarName, origArraySizeVarName, memHndlName)
	<< ";\n";
      // print out the malloc for the linked array
      indent(os, indentCount) 
	<< "mdat_malloc_list(" << origArraySizeVarName << " * sizeof *" << copyVarName << ", " 
	<< "(void **) &("+copyVarName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << origArraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level Copy
      printCCopy (os, copyStructPtrName, origStructPtrName, memHndlName, 
		  ++loopVarCount, usedLenNames, 
		  "(" + copyVarName + ")" + "[" + loopVar + "]", 
		  "(" + origVarName + ")" + "[" + loopVar + "]", 
		  level-1);
      // print out the linking logic
      indent(os, indentCount+1) 
	<< "if (" << loopVar << ") " 
	<< "(" + copyVarName + ")" + "[" + loopVar + "-1]." << typePtr->getLinkVar() << " = &("
	<< "(" + copyVarName + ")" + "[" + loopVar + "]);\n";
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // print out the switch on if this ptr points to something
      indent(os, indentCount)
	<< "if (" << origVarName << ") {\n";
      {
	// print out the malloc for the ptr
	indent(os, indentCount+1) 
	  << "mdat_malloc_list (sizeof *" << copyVarName << ", " 
	  << "(void **) &("+copyVarName+")" << ", " << memHndlName << ");\n";
	// print out the next level Copy
	printCCopy (os, copyStructPtrName, origStructPtrName, memHndlName, 
		    loopVarCount, usedLenNames, 
		    "*(" + copyVarName + ")", 
		    "*(" + origVarName + ")", 
		    level-1);
      }
      indent(os, indentCount)
	<< "} else {\n";
      {
	// set the var to NULL
	indent(os, indentCount+1)
	  << copyVarName << " = NULL;\n";
	// if it's a pointer to an array, we need to zero the size of it as well
	if (level>=2 && typeQuals[level-2].isArray()) {
	  std::string lenName = typeQuals[level-2].getLenName();
	  if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
	    std::string szName = getSzName (copyStructPtrName+"->"+lenName, level);
	    indent(os, indentCount+1)
	      << "  " << szName << " = 0;\n";
	  }
	}
      }
      indent(os, indentCount)
	<< "}\n";
    }
  else if (typeQuals[level-1].isVarArray())
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string copyArraySizeVarName = getSzName (copyStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      std::string origArraySizeVarName = getSzName (origStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the Copy for the size of the array
      indent(os, indentCount) 
	<< DataTypeInfo::get ("short_sy")->getCCopy (copyArraySizeVarName, origArraySizeVarName, memHndlName)
	<< ";\n";
      // we're now sure that this lenName is fully malloc'ed
      usedLenNames.push_back (typeQuals[level-1].getLenName());
      // print out the malloc for the all the sub-array size variables as needed,
      for (std::vector<TypeQualifier>::size_type i = level-1; i>0; i-- )
	if (typeQuals[i-1].isArray()) 
	  {
	    // check to see if this sizeVar has already been malloc()'ed
	    std::vector<std::string>::size_type j;
	    for (j=0; j<usedLenNames.size(); j++)
	      if (typeQuals[i-1].getLenName() == usedLenNames[j]) break;
	    if (j == usedLenNames.size()) { // it's not, so print the malloc
              std::string lenName = typeQuals[i-1].getLenName();
              if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
		std::string szName = getSzName (copyStructPtrName+"->"+lenName, level);
		indent(os, indentCount) 
		  << "mdat_malloc_list(" << origArraySizeVarName << " * sizeof *" 
		  << szName << ", " << "(void **) &("+szName+")" << ", " << memHndlName << ");\n";
	      }
	    }
	  }
      // print out the malloc for the var itself (at this level)
      indent(os, indentCount) 
	<< "mdat_malloc_list(" << origArraySizeVarName << " * sizeof *" << copyVarName << ", " 
	<< "(void **) &("+copyVarName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << origArraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level Copy
	printCCopy (os, copyStructPtrName, origStructPtrName, memHndlName, 
		    ++loopVarCount, usedLenNames, 
		    "(" + copyVarName + ")" + "[" + loopVar + "]", 
		    "(" + origVarName + ")" + "[" + loopVar + "]", 
		    level-1);
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }
  else // (typeQuals[level-1].isFixedArray())
    {
      std::string loopVar;
      {
	std::ostrstream tt; tt << "i_"<< loopVarCount << std::ends;
	loopVar = tt.str(); tt.freeze(false);
      }
      std::string copyArraySizeVarName = getSzName (copyStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      std::string origArraySizeVarName = getSzName (origStructPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // print out the Copy for the size of the array
      indent(os, indentCount) 
	<< DataTypeInfo::get ("short_sy")->getCCopy (copyArraySizeVarName, origArraySizeVarName, memHndlName)
	<< ";\n";
      // print out the for-loop for this array
      indent(os, indentCount) 
	<< "for (" << loopVar << " =0; " << loopVar << " < " << origArraySizeVarName 
	<< "; " << loopVar << "++) {\n";
      // print out the next level copy
      printCCopy (os, copyStructPtrName, origStructPtrName, memHndlName, 
		  ++loopVarCount, usedLenNames, 
		  "(" + copyVarName + ")" + "[" + loopVar + "]", 
		  "(" + origVarName + ")" + "[" + loopVar + "]", 
		  level-1);
      // close out the for-loop for this array
      indent(os, indentCount)
      	<< "}\n";
    }    
} 

void MDataMemberInfo::printCOstrmPrint (std::ostream & os, const std::string & ostrmPtrName, 
					const std::string & structPtrName, int & loopVarCount, 
					const std::string & nameVarName, const std::string & varName, 
					std::vector<TypeQualifier>::size_type level) const {
  int indentCount = (typeQuals.size()-level)*3 + 3;
  if (level == 0)
    {
      // simply printout the mdat_ostrm_print for this type
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCOstrmPrint (ostrmPtrName, varName, nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCArrayOstrmPrint (ostrmPtrName, varName, 
					 getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level),
					 nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string linkPtrName = "_" + getName() + "_ptr";
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin print for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_ostrm_print_array_begin (" << ostrmPtrName << ", " << arraySizeVarName
        << ", " << nameVarName << ", \"" << typePtr->getCName() << "[]\")))\n";
      indent(os, indentCount+1) 
	<< "{ if (rc!=MDAT_OSTRM_ERR_LEVEL_TOO_DEEP) return rc; }\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // initialize the link node pointer
      indent(os, indentCount+2) 
	<< linkPtrName << " = " << varName << ";\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level ostrmPrint
      printCOstrmPrint (os, ostrmPtrName, structPtrName, ++loopVarCount, 
			"\"\"", "*("+linkPtrName+")", level-1);
      // print out the linking logic
      indent(os, indentCount+3) 
	<< linkPtrName << " = " << linkPtrName << "->" << typePtr->getLinkVar() << ";\n";
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_ostrm_print_array_end (" << ostrmPtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // begin print for the ptr
      indent(os, indentCount) 
	<< "if ((rc=mdat_ostrm_print_ptr_begin (" << ostrmPtrName << ", " << varName
        << ", " << nameVarName << ", \"Ptr\"" << ")))\n";
      indent(os, indentCount+1) 
	<< "{ if (rc!=MDAT_OSTRM_ERR_LEVEL_TOO_DEEP) return rc; }\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the switch on if this ptr points to something
      indent(os, indentCount+2)
	<< "if (" << varName << ") {\n";
      // print out the next level ostrmPrint
      printCOstrmPrint (os, ostrmPtrName, structPtrName, loopVarCount, 
			"\"\"", "*("+varName+")", level-1);
      indent(os, indentCount+2)
	<< "}\n";
      // end print for the ptr
      indent(os, indentCount+2) 
        << "if ((rc=mdat_ostrm_print_ptr_end (" << ostrmPtrName << "))) return rc;\n";
      indent(os, indentCount+1)
	<< "}\n";
    }
  else
    {
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin print for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_ostrm_print_array_begin (" << ostrmPtrName << ", " << arraySizeVarName
        << ", " << nameVarName << ", \"Array\")))\n";
      indent(os, indentCount+1) 
	<< "{ if (rc!=MDAT_OSTRM_ERR_LEVEL_TOO_DEEP) return rc; }\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level ostrmPrint
      std::ostrstream tt; tt << "(" << varName << ")" << "[i_"<< loopVarCount << "]" << std::ends;
      printCOstrmPrint (os, ostrmPtrName, structPtrName, ++loopVarCount, 
		    "\"\"", tt.str(), level-1);
      tt.freeze(false);
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_ostrm_print_array_end (" << ostrmPtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
}

void MDataMemberInfo::printCSTreePut (std::ostream & os, const std::string & streePtrName, 
					const std::string & structPtrName, int & loopVarCount, 
					const std::string & nameVarName, const std::string & varName, 
					std::vector<TypeQualifier>::size_type level) const {
  int indentCount = (typeQuals.size()-level)*3 + 3;
  if (level == 0)
    {
      // simply printout the stree_put for this type
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCSTreePut (streePtrName, varName, nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCArraySTreePut (streePtrName, varName, 
				       getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level),
				       nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string linkPtrName = "_" + getName() + "_ptr";
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin print for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_put_array_begin (" << streePtrName << ", " << arraySizeVarName
        << ", " << nameVarName << "))) return rc;\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // initialize the link node pointer
      indent(os, indentCount+2) 
	<< linkPtrName << " = " << varName << ";\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level stree put
      printCSTreePut (os, streePtrName, structPtrName, ++loopVarCount, 
			"\"\"", "*("+linkPtrName+")", level-1);
      // print out the linking logic
      indent(os, indentCount+3) 
	<< linkPtrName << " = " << linkPtrName << "->" << typePtr->getLinkVar() << ";\n";
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_put_array_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // begin print for the ptr
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_put_ptr_begin (" << streePtrName << ", " << varName
        << ", " << nameVarName << "))) return rc;\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the switch on if this ptr points to something
      indent(os, indentCount+2)
	<< "if (" << varName << ") {\n";
      // print out the next level stree put
      printCSTreePut (os, streePtrName, structPtrName, loopVarCount, 
			"\"dat\"", "*("+varName+")", level-1);
      indent(os, indentCount+2)
	<< "}\n";
      // end print for the ptr
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_put_ptr_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1)
	<< "}\n";
    }
  else
    {
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin print for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_put_array_begin (" << streePtrName << ", " << arraySizeVarName
        << ", " << nameVarName << "))) return rc;\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      indent(os, indentCount+2) 
        << "char elem[256];\n";
      indent(os, indentCount+2) 
        << "sprintf (elem, \"elem_%ld\", i_" << loopVarCount << ");\n";
      // print out the next level stree put
      std::ostrstream tt; tt << "(" << varName << ")" << "[i_"<< loopVarCount << "]" << std::ends;
      printCSTreePut (os, streePtrName, structPtrName, ++loopVarCount, 
		    "elem", tt.str(), level-1);
      tt.freeze(false);
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_put_array_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
}

void MDataMemberInfo::printCSTreeGet (std::ostream & os, const std::string & streePtrName, 
				      const std::string & structPtrName, 
				      const std::string & memHndlName, 
				      int & loopVarCount, std::vector<std::string> & usedLenNames,
				      const std::string & nameVarName, const std::string & varName, 
				      std::vector<TypeQualifier>::size_type level) const {
  int indentCount = (typeQuals.size()-level)*3 + 3;
  if (level == 0)
    {
      // simply printout the stree_get for this type
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCSTreeGet (streePtrName, memHndlName, varName, nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->specializesArray()) )
    {
      // this type specializes the Array qualifier
      indent(os, indentCount) 
	<< "if ((rc="
	<< typePtr->getCArraySTreeGet (streePtrName, memHndlName, varName, 
				       getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level),
				       nameVarName)
	<< ")) return rc;\n";
    }
  else if ( (level == 1) 
	    && (typeQuals[0].isArray())
	    && (typePtr->isLink()) )
    {
      std::string linkPtrName = "_" + getName() + "_ptr";
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin print for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_get_array_begin (" << streePtrName << ", &" << arraySizeVarName
        << ", " << nameVarName << ")))\n";
      indent(os, indentCount+1)  // we'll just skip if key is not found.
	<< "{if (rc!=STREE_ERR_INVALID_KEY) return rc;}\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // initialize the link node pointer
      indent(os, indentCount+2) 
	<< linkPtrName << " = " << varName << ";\n";
      // print out the malloc for the linked array
      indent(os, indentCount) 
	<< "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" << varName << ", " 
	<< "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      // print out the next level stree get
      printCSTreeGet (os, streePtrName, structPtrName, memHndlName, ++loopVarCount, usedLenNames,
			"\"\"", "*("+linkPtrName+")", level-1);
      // print out the linking logic
      indent(os, indentCount+3) 
	<< linkPtrName << " = " << linkPtrName << "->" << typePtr->getLinkVar() << ";\n";
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_get_array_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
  else if (typeQuals[level-1].isPtr())
    {
      // begin print for the ptr
      indent(os, indentCount) 
        << "{\n";
      indent(os, indentCount) 
	<< "short_sy has_dat;\n";
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_get_ptr_begin (" << streePtrName << ", " << "&has_dat"
        << ", " << nameVarName << ")))\n";
      indent(os, indentCount+1)  // we'll just skip if key is not found.
	<< "{if (rc!=STREE_ERR_INVALID_KEY) return rc;}\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the switch on if this ptr points to something
      indent(os, indentCount+2)
	<< "if (" << "has_dat" << ") {\n";
      {
	// print out the malloc for the ptr
	indent(os, indentCount+3) 
	  << "mdat_malloc_list (sizeof *" << varName << ", " 
	  << "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
	// print out the next level stree get
	printCSTreeGet (os, streePtrName, structPtrName, memHndlName, loopVarCount, usedLenNames,
			"\"dat\"", "*("+varName+")", level-1);
      }
      indent(os, indentCount+2)
	<< "} else {\n";
      indent(os, indentCount+3)
	<< "  " << varName << " = NULL;\n";
      // if it's a pointer to an array, we need to zero the size of it as well
      if (level>=2 && typeQuals[level-2].isArray()) {
	std::string lenName = typeQuals[level-2].getLenName();
	if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
	  std::string szName = getSzName (structPtrName+"->"+lenName, level);
	  indent(os, indentCount+3)
	    << "  " << szName << " = 0;\n";
	}
      }
      indent(os, indentCount+2)
	<< "}\n";
      // end print for the ptr
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_get_ptr_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1)
	<< "}\n";
      indent(os, indentCount)
	<< "}\n";
    }
  else if (typeQuals[level-1].isVarArray())
    {
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin stree_get for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_get_array_begin (" << streePtrName << ", &" << arraySizeVarName
        << ", " << nameVarName << ")))\n";
      indent(os, indentCount+1)  // we'll just skip if key is not found.
	<< "{if (rc!=STREE_ERR_INVALID_KEY) return rc;}\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // we're now sure that this lenName is fully malloc'ed
      usedLenNames.push_back (typeQuals[level-1].getLenName());
      // print out the malloc for the all the sub-array size variables as needed,
      for (std::vector<TypeQualifier>::size_type i = level-1; i>0; i-- )
	if (typeQuals[i-1].isArray()) 
	  {
	    // check to see if this sizeVar has already been malloc()'ed
	    std::vector<std::string>::size_type j;
	    for (j=0; j<usedLenNames.size(); j++)
	      if (typeQuals[i-1].getLenName() == usedLenNames[j]) break;
	    if (j == usedLenNames.size()) { // it's not, so print the malloc
              std::string lenName = typeQuals[i-1].getLenName();
              if (!lenName.empty()) { // take care of the case (e.g. cstring) where there is no size variable
		std::string szName = getSzName (structPtrName+"->"+lenName, level);
		indent(os, indentCount+2) 
		  << "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" 
		  << szName << ", " << "(void **) &("+szName+")" << ", " << memHndlName << ");\n";
	      }
	    }
	  }
      // print out the malloc for the var itself (at this level)
      indent(os, indentCount+2) 
	<< "mdat_malloc_list(" << arraySizeVarName << " * sizeof *" << varName << ", " 
	<< "(void **) &("+varName+")" << ", " << memHndlName << ");\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      indent(os, indentCount+2) 
        << "char elem[256];\n";
      indent(os, indentCount+2) 
        << "sprintf (elem, \"elem_%ld\", i_" << loopVarCount << ");\n";
      // print out the next level stree get
      std::ostrstream tt; tt << "(" << varName << ")" << "[i_"<< loopVarCount << "]" << std::ends;
      printCSTreeGet (os, streePtrName, structPtrName, memHndlName, ++loopVarCount, usedLenNames,
		    "elem", tt.str(), level-1);
      tt.freeze(false);
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_get_array_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    }
  else // (typeQuals[level-1].isFixedArray())
     {
      std::string arraySizeVarName = getSzName (structPtrName+"->"+typeQuals[level-1].getLenName(), level);
      // begin stree_get for the array
      indent(os, indentCount) 
	<< "if ((rc=mdat_stree_get_array_begin (" << streePtrName << ", &" << arraySizeVarName
        << ", " << nameVarName << ")))\n";
      indent(os, indentCount+1)  // we'll just skip if key is not found.
	<< "{if (rc!=STREE_ERR_INVALID_KEY) return rc;}\n";
      indent(os, indentCount) 
	<< "else\n";
      indent(os, indentCount+1) 
	<< "{\n";
      // print out the for-loop for this array
      indent(os, indentCount+2) 
	<< "for (i_" << loopVarCount << " =0; i_" << loopVarCount << " < " << arraySizeVarName 
	<< "; i_" << loopVarCount << "++) {\n";
      indent(os, indentCount+3) 
        << "char elem[256];\n";
      indent(os, indentCount+3) 
        << "sprintf (elem, \"elem_%ld\", i_" << loopVarCount << ");\n";
      // print out the next level stree get
      std::ostrstream tt; tt << "(" << varName << ")" << "[i_"<< loopVarCount << "]" << std::ends;
      printCSTreeGet (os, streePtrName, structPtrName, memHndlName, ++loopVarCount, usedLenNames,
		    "elem", tt.str(), level-1);
      tt.freeze(false);
      // close out the for-loop for this array
      indent(os, indentCount+2)
      	<< "}\n";
      // end print for the array
      indent(os, indentCount+2) 
        << "if ((rc=mdat_stree_get_array_end (" << streePtrName << "))) return rc;\n";
      indent(os, indentCount+1) 
	<< "}\n";
    } 
}


void MDataMemberInfo::printCDeclaration (std::ostream & os, std::vector<std::string> & usedLenNames, const std::string & className) const {
  // take care of array size variables, if any
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (!typeQuals[i-1].getLenName().empty())
      {
	// first check to make sure it's not already declared.
	std::vector<std::string>::size_type j;
	for (j=0; j<usedLenNames.size(); j++)
	  if (typeQuals[i-1].getLenName() == usedLenNames[j]) break;
	if (j == usedLenNames.size())
	  {
	    std::string arraySizeType = "short_sy ";
	    std::string arraySizeVarName = typeQuals[i-1].getLenName();
	    // fully qualify the size variable name
	    for (std::vector<TypeQualifier>::size_type k = typeQuals.size(); k>i; k--)
	      if (typeQuals[k-1].isVarArray())
		arraySizeVarName = "*("+arraySizeVarName+")";
	      else if (typeQuals[k-1].isFixedArray()) {
		std::string upperClassName = className+"_";
		transform (upperClassName.begin(), upperClassName.end(), upperClassName.begin(), toupper);
		arraySizeVarName ="("+ arraySizeVarName+")["+upperClassName+typeQuals[k-1].getMaxLenName()+"]";
	      }
	    // print out
	    if (arraySizeType[arraySizeType.size()-1] != ' ') arraySizeType += ' ';
	    printDecOneLine (os, arraySizeType, arraySizeVarName + ';');
	    os << "\n";
	    usedLenNames.push_back (typeQuals[i-1].getLenName());
	  }
      }
  // now for the actual variable
  std::string mType = getTypePtr()->getCName()+" ";
  std::string mName = getName();
  // fully qualify the variable name
  for (std::vector<TypeQualifier>::size_type i = typeQuals.size(); i>0; i--)
    if (typeQuals[i-1].isVarArray() || typeQuals[i-1].isPtr())
      mName = "*("+mName+")";
    else if (typeQuals[i-1].isFixedArray()) {
      std::string upperClassName = className+"_";
      transform (upperClassName.begin(), upperClassName.end(), upperClassName.begin(), toupper);
      mName ="("+ mName+")["+upperClassName+typeQuals[i-1].getMaxLenName()+"]";
    }
  // print out
  if (isConst()) {
    std::string macroName = className + "_" +  getName();
    transform (macroName.begin(), macroName.end(), macroName.begin(), toupper);
    printDecDefine (os, macroName, defVal);
  } else {
    printDecOneLine (os, mType, mName+';');
  }
  if (!comments.empty())
    {
	    std::ios::fmtflags oldFlags = os.flags();
      os << " /*" << comments[0] << " */";
      for (std::vector<std::string>::size_type i=1; i<comments.size(); i++)
	os << '\n' << setw(50) << " " 
	   << " /*" << comments[i] << " */";
      os.flags(oldFlags);
    }
  os << '\n';
}

void MDataMemberInfo::printCPPDeclaration (std::ostream & os) const {
  std::string typeName;
  if (isConst()) typeName = "static const ";
  typeName += getCPPQualTypeName()+" ";
  printDecOneLine (os, typeName, getName()+';');
  if (!comments.empty())
    {
	    std::ios::fmtflags oldFlags = os.flags();
      os << " //" << comments[0];
      for (std::vector<std::string>::size_type i=1; i<comments.size(); i++)
	os << '\n' << setw(50) << " " 
	   << " //" << comments[i];
      os.flags(oldFlags);
    }
  os << '\n';
}

void MDataMemberInfo::printCPPIntDef (std::ostream & os, 
				      bool autoSetMsgFlag, const std::string & msgFlagVarName, 
				      const std::string flagConstName) const {
  os << "  void " << "setX"+getName() << " (" << getCPPQualTypeName() << " const& in) {\n"
     << "    " << getName() << " = in;\n";
  if (autoSetMsgFlag)
    os << "    " << msgFlagVarName << " |= " << flagConstName << ";\n";
  os << "  }\n";
  os << "  " << getCPPQualTypeName() << " getX"+getName() << " () const {\n"
     << "    return " << getName() << ";\n"
     << "  }\n";
  os << '\n';
}

void MDataMemberInfo::printJDeclaration (std::ostream & os) const {
  os << "  public ";
  std::string typeName = getJQualTypeName();
  std::string nameAndVal = getName() + ';';
  if (isConst()) {
    typeName = "static final " + getJQualTypeName();
    nameAndVal = getName() + " = ";
    // Special code to handle the case that the type is char (byte in Java).
    // We must cast in this case, since byte is smaller than "char" in Java
    // and the defVal would be specified as a constant "char" (e.g., 'A').
    // Similar problem for uchar_sy (byte), and ulong_sy (int).
    if ( (getJQualTypeName() == "byte")
	 || (getJQualTypeName() == "short")
	 || (getJQualTypeName() == "int") ) {
      nameAndVal += "(" + getJQualTypeName() + ") "; 
    }
    nameAndVal += defVal + ";";
  }
  printDecOneLine (os, typeName + " ", nameAndVal); 
  if (!comments.empty())
    {
	    std::ios::fmtflags oldFlags = os.flags();
      os << " //" << comments[0];
      for (std::vector<std::string>::size_type i=1; i<comments.size(); i++)
	os << '\n' << setw(52) << " " 
	   << " //" << comments[i];
      os.flags(oldFlags);
    }
  os << '\n';
}

void MDataMemberInfo::printJIntDef (std::ostream & os, const std::string & this_str, 
				    bool autoSetMsgFlag, const std::string & msgFlagVarName, 
				    const std::string flagConstName) const {
  os << "  public void " << "setX"+getName() << " (" << getJQualTypeName() << " in) {\n"
     << "    " << this_str+"." +getName() << " = in;\n";
  if (autoSetMsgFlag)
    os << "    " << msgFlagVarName << " |= " << flagConstName << ";\n";
  os << "  }\n";
  os << "  public " << getJQualTypeName() << " getX"+getName() << " () {\n"
     << "    return " << this_str+"."+getName() << ";\n"
     << "  }\n";
  os << '\n';
}

//
// MDataTypeInfo implementations
//
MDataTypeInfo::MDataTypeInfo (const std::string & _name, const MDataQualifier * _qual, 
			      Component _comps, const std::vector<MDataMemberInfo> & _members) : 
  Base (_name), members(_members),
  b_IsCtlMsg (false), b_IsInner(false), b_IsLink(false), b_IsVisual(false), b_IsFormat(false),
  b_ParserUsesMSList(false), b_CompService(false)
{ 
  dispMemberIdx = members.size();
  // Set the qualifiers
  if (_qual)
    {
      if (_qual->flag & FLAG_IS_CONTROL)
	{
	  std::string keyword = "TOK_" + getName();
	  transform (keyword.begin(), keyword.end(), keyword.begin(), toupper);
          setKeyword (keyword, "MDat_"+getName());
	  std::vector<MDataMemberInfo>::size_type i;
	  for (i= 0; i < members.size(); i++)
	    if ( (!members[i].isConst()) && (members[i].getName() == _qual->controlVar)) break; 
	  if (i == members.size())
	    throw msgc_exception(_qual->controlVar+" is not found as a member in control mdata "+_name);
          controlVar = _qual->controlVar;
	}
      if (_qual->flag & FLAG_IS_LINK)
	{
	  b_IsLink = true;
//	  b_IsInner = true;
          linkVar = _qual->linkVar;
	}
      if (_qual->flag & FLAG_IS_INNER)
	b_IsInner = true;
      if (_qual->flag & FLAG_IS_VISUAL)
	{
	  b_IsVisual = true;
	  for (dispMemberIdx = 0; dispMemberIdx < members.size(); dispMemberIdx++)
	    if ( (!members[dispMemberIdx].isConst()) && (members[dispMemberIdx].getName() == _qual->visualVar)) break; 
	  if (dispMemberIdx == members.size())
	    throw msgc_exception(_qual->visualVar+" is not found as a member in "+_name);
	}
      if (_qual->flag & FLAG_IS_FORMAT)
	{
	  b_IsFormat = true;
	  formatString = _qual->formatVar;
	}
    }
  // Set the components
  if (_comps & COMP_SERVICE)
    b_CompService = true;
  // Check for the variable name conflicts.
  for (std::vector<MDataMemberInfo>::size_type i= 0; i < members.size(); i++)
    for (std::vector<MDataMemberInfo>::size_type k= i+1; k < members.size(); k++)
      if (members[i].getName()==members[k].getName())
	throw msgc_exception( "mdata member variable name " + members[i].getName() +
			      " is used twice in mdata " + getName() + "." );
  // Now we want to check conflicts with length names.
  // This is a bit tricky since we allow same "length" names (array size
  // variable) to have the same name at the same level (dimensionality), 
  // if the lower level array size variables are also the same.  (I.e., 
  // we allow sharing of array size information amongst different arrays.)
  // So, for example, in
  //   typeA [lenName1][lenName2][lenName3] nameA;
  //   typeB [lenName4][lenName3] nameB;
  //   typeC [lenName2]*[lenName3] nameC;
  //   typeD [lenName2][lenName5] nameC;
  // "B" and "C" are allowed, but "D" is invalid.
  // We do this by consolidating all the length names, checking in the
  // case of duplicates if the above criterion is met.
  // Note also that length names can not be shared across levels.
  // E.g., 
  //   typeE [lenName6][lenName6] nameE;
  // is invalid.
  {
    std::vector<std::string> allLenNames; // stores lenNames from lower levels
    for (std::vector<TypeQualifier>::size_type level=1; ; level++)
    {
      // lenNameIdx stores lenNames from this level via index to the array "members."
      std::vector<std::vector<MDataMemberInfo>::size_type> lenNameIdx; 
      lenNameIdx.clear();
      // we'll assume our level is too deep until shown otherwise
      bool done = true;
      for (std::vector<MDataMemberInfo>::size_type i= 0; i < members.size(); i++)
	{
	  std::string currLenName = members[i].getLenNameAtLevel (level);
	  if (currLenName.empty()) continue;
	  done = false;  // we have length names at this level, so we're not done yet.
	  // check to see if this new lenName matched a previous one at this level
	  std::vector<std::string>::size_type k;
	  for (k= 0; k < lenNameIdx.size(); k++)
	    if (currLenName == members[lenNameIdx[k]].getLenNameAtLevel (level))
	      { 
		// found a match with another lenName, so we need to check if lenNames agree at lower levels
		for (std::vector<TypeQualifier>::size_type l=level-1; l > 0; l--)
		  {
		    if (members[i].getLenNameAtLevel(l) != members[lenNameIdx[k]].getLenNameAtLevel(l) )
		      throw msgc_exception( "shared array size name " + currLenName +
					    " must share size names at lower dimensionalities in " 
					    + getName() + "." );
		    if (members[i].getMaxLenNameAtLevel(l) != members[lenNameIdx[k]].getMaxLenNameAtLevel(l) )
		      throw msgc_exception( "shared array size name " + currLenName +
					    " must have same array types at lower dimensionalities in " 
					    + getName() + "." );
		  }
		break;
	      }
	  if (k == lenNameIdx.size()) 
	    { 
	      // no match, so this is a new lenName for this level
	      // check for conflict with variable names
	      for (std::vector<MDataMemberInfo>::size_type l= 0; l < members.size(); l++)
		if (currLenName == members[l].getName())
		  throw msgc_exception( "mdata member variable name " + members[l].getName() +
					" conflicts with an array size name in mdata " 
					+ getName() + "." );
	      // check for conflict with lower level lenNames
	      for (std::vector<std::string>::size_type l= 0; l < allLenNames.size(); l++)
		if (currLenName == allLenNames[l])
		  throw msgc_exception( "array size name " + currLenName +
					" conflicts with another array size name with lower" +
					" dimensionality in mdata " + getName() + "." );
              // save this lenName via the lenNameIdx.
	      lenNameIdx.push_back (i);
	    }
	}
      // if no lenName found at this level, break out of the loop
      if (done) break;
      // store all the new lenNames at this level into "allLenNames"
      for (std::vector<std::string>::size_type k = 0; k < lenNameIdx.size(); k++)
	allLenNames.push_back (members[lenNameIdx[k]].getLenNameAtLevel(level));
    }
  }

  // If this is a "link" mdata, we need to make sure that the linkage variable (default: "next") is not
  // a declared variable.  we need to reserve this variable for pointer to itself in
  // the C translation.
  if (isLink())
    {
      for (std::vector<MDataMemberInfo>::size_type i= 0; i < members.size(); i++)
	{
	  if (members[i].getName() == linkVar)
	    throw msgc_exception( "an explicitly declared variable " + linkVar +
				  " conflicts with linkage variable name in link mdata " + getName() + ".");
	  for (std::vector<TypeQualifier>::size_type j=0; j<members[i].typeQuals.size(); j++)
	    if (members[i].typeQuals[j].getLenName() == linkVar)
	      throw msgc_exception( "an array size variable " + linkVar +
				    " conflicts with linkage variable name in link mdata " + getName() + ".");
	}
    }
  else // we need to check that "reqid" is not a declared variable.
    {
      for (std::vector<MDataMemberInfo>::size_type i= 0; i < members.size(); i++)
	{
	  if (members[i].getName() == STR_REQID)
	    throw msgc_exception( "a variable with name " + STR_REQID +
				  " can not be explicitly declared in mdata " + getName() + ".");
	  for (std::vector<TypeQualifier>::size_type j=0; j<members[i].typeQuals.size(); j++)
	    if (members[i].typeQuals[j].getLenName() == STR_REQID)
	      throw msgc_exception( "a size variable with name " + STR_REQID +
				    " can not be used in mdata " + getName() + ".");
	}
    }

  // msg_flags
  /*
  {
    // check to see if x_msg_flags is not a declared variable
    flagVarName = _name + "_msg_flags";
    for (std::vector<MDataMemberInfo>::size_type i=0; i < members.size(); i++)
      {
	if (members[i].getName() == flagVarName)
	  throw msgc_exception( "a variable with name " + flagVarName +
				" can not be explicitly declared in mdata " + getName() + ".");
	for (std::vector<TypeQualifier>::size_type j=0; j<members[i].typeQuals.size(); j++)
	  if (members[i].typeQuals[j].getLenName() == flagVarName)
	    throw msgc_exception( "a size variable with name " + flagVarName +
				  " can not be used in mdata " + getName() + ".");
      }
    // introduce the x_msg_flags var
    members.push_back (
	MDataMemberInfo (flagVarName, 0, std::string("long_sy"), std::vector<TypeQualifier>(), 
			 std::string("0"), MDataVisualInfo(), std::vector<std::string>()));
    // introduce the X_MSG_FLAGS_Y consts
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) 
      if ( (!members[i].isConst()) && (members[i].getName() != flagVarName)) {
	  std::string flagName = "MSG_FLAGS_" + members[i].getName();
	  transform (flagName.begin(), flagName.end(), flagName.begin(), toupper);
	  std::strstream flagVal;
	  flagVal << "0x" << std::hex << setfill('0') << setw(8) << (1 << i) << std::ends;
	  members.push_back ( MDataMemberInfo (flagName, 1, std::string("long_sy"), std::vector<TypeQualifier>(),
					       flagVal.str(), MDataVisualInfo(), std::vector<std::string>()));
      }
  }
  */

  // check to see if the parser uses ms_list subsystem
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size() && !b_ParserUsesMSList; i++)
    if (!members[i].isConst()) {
      if (members[i].getTypePtr()->parserUsesMSList()) {
	    b_ParserUsesMSList = true;
	    break;
      }
      for (std::vector<TypeQualifier>::size_type j=0; j<members[i].typeQuals.size(); j++)
	if (members[i].typeQuals[j].b_ParserUsesMSList) 
	  {
	    b_ParserUsesMSList = true;
	    break;
	  };
    }	
  
  // put this in the global store, and set the mangled names
  store.insert(_name,Ptr(this)); 
  setMangledNames ();
}

void MDataTypeInfo::setKeyword (const std::string & _keyword, const std::string & _className) {
  b_IsCtlMsg = true;
  keyword = _keyword;
  KeywordTab::get().add(keyword, keyword, _className);
}

void MDataTypeInfo::printCDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C Declaration for mdata " + getName());
  os << '\n';

  // need the uppercase version of my name
  std::string upperName = getName();
  //    std::use_facet<std::ctype<char> >(std::locale::classic()).toupper (upperName.begin(), upperName.end());
  // for (std::string::size_type i=0; i<upperName.size(); i++) upperName[i] = toupper(upperName[i]);
  transform (upperName.begin(), upperName.end(), upperName.begin(), toupper);

  // C specific .h file stuff
  {
    // struct (mdat_X) declaration
    {
      os << "typedef struct " << getName()+"_msg" << " {\n";
      if (!isInner()) 
	{
	  MDataMemberInfo::printDecOneLine (os, "REQID ", "reqid;");
	  os << '\n';
	}
      std::vector<std::string> usedLenNames;
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (members[i].getName() != getFlagVarName())
	  members[i].printCDeclaration (os, usedLenNames, getName());
      if (isLink()) 
	{
	  MDataMemberInfo::printDecOneLine (os, "struct " + getName()+"_msg" + " * ", linkVar+";");
	  os << '\n';
	}
      os << "} " << getCName() << ";\n";
/*
      // MSG_FLAG backward compatible define's
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
	  std::string flagName = getName() + "_MSG_FLAGS_" + members[i].getName();
	  transform (flagName.begin(), flagName.end(), flagName.begin(), toupper);
	  // these two aliases are for backward compatibility
          if (members[i].getName() == "requestor") {
	    std::string aliasName = getName() + "_MSG_FLAGS_CREATOR";
	    transform (aliasName.begin(), aliasName.end(), aliasName.begin(), toupper);
	    os << "#define "
	       << std::setiosflags(std::ios::left) << setw(40) << aliasName.c_str() << std::resetiosflags(std::ios::left)
	       << " " << flagName << "\n";
	  }
          if (members[i].getName() == "request_time") {
	    std::string aliasName = getName() + "_MSG_FLAGS_CREATION_TIME";
	    transform (aliasName.begin(), aliasName.end(), aliasName.begin(), toupper);
	    os << "#define "
	       << std::setiosflags(std::ios::left) << setw(40) << aliasName.c_str() << std::resetiosflags(std::ios::left)
	       << " " << flagName << "\n";
	  }
	}
*/
      // backward compatibility typedefs
      os << "typedef " << getCName() << " " << "msg_type_"+getName() << ";\n";
      os << "typedef " << getCName() << "* " << "msg_type_"+getName()+"_ptr" << ";\n";
      os << "typedef " << getCName() << " " << "MSG_TYPE_"+upperName << ";\n";
    }
    os << '\n';

    // C mdat_create/parse functions declarations
    {
      os << "rcode_sy " << "mdat_create_"+getName() 
	 << " (char_sy ** bs_pp, const char_sy * be_p, const " << getCName() << " *dat_p);\n"
	 << "rcode_sy " << "mdat_parse_"+getName() << " (const char_sy **bs_pp, " << getCName() << " *dat_p";
      if (parserUsesMSList()) os << ", short_sy mem_hndl";
      os << ");\n";
    }

    // C mdat_copy function declaration
    {
      os << "rcode_sy " << "mdat_copy_"+getName() 
	 << " (" << getCName() << " * copy_p, const " << getCName() << " * orig_p";
      if (parserUsesMSList()) os << ", short_sy mem_hndl";
      os << ");\n";
    }

    // C mdat_ostrm_print function declaration
    {
      os << "rcode_sy " << "mdat_ostrm_print_"+getName() 
	 << " (mdat_ostrm_t * _os, const " << getCName() << " * _dat_p, const char * _name);\n";
    }	
    
    // C mdat_stree_put function declaration
    {
      os << "rcode_sy " << "mdat_stree_put_"+getName() 
	 << " (stree_t * _stree, const " << getCName() << " * _dat_p, const char * _name);\n";
    }	
    
    // C mdat_stree_get function declaration
    {
      os << "rcode_sy " << "mdat_stree_get_"+getName() 
	 << " (stree_t * _stree, " << getCName() << " * _dat_p, const char * _name, short_sy mem_hndl);\n";
    }	
    
    // C mdat_print function declaration
    {
      os << "rcode_sy " << "mdat_print_"+getName() 
	 << " (const " << getCName() << " * _dat_p, const char * _name);\n";
    }	
    
    // if control mdat, C msg_create/parse functions declarations
    if (isCtlMsg())
      {
	os << '\n';
	os << "long_sy " << "msg_create_"+getName()
	   << " (const " << getCName() << " *sp, char_sy *bs, const char_sy *be);\n";
	os << "rcode_sy " << "msg_parse_"+getName() << " (const char_sy *bs, " << getCName() << " *sp";
	if (parserUsesMSList()) os << ", short_sy mem_hndl";
	os << ");\n";
      }

    // if not inner mdat, C mdat_msg_create/parse functions declarations
    if (!isInner())
      {
	os << "long_sy " << "mdat_msg_create_"+getName() 
	   << " (const " << getCName() << " *sp, char_sy *bs, const char_sy *be, keyword_sy msgcode);\n";
	os << "rcode_sy " << "mdat_msg_parse_"+getName() << " (const char_sy *bs, " << getCName() << " *sp";
	if (parserUsesMSList()) os << ", short_sy mem_hndl";
	os << ", keyword_sy msgcode);\n";
      }

    // Inclusion (H)
    if (incInfo.hasInclusion(InclusionInfo::INC_H)) {
      os << '\n';
      incInfo.printInclusion (os, InclusionInfo::INC_H);
    }
  }
  os << '\n';
}

void MDataTypeInfo::printCPPDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C++ Declaration for mdata " + getName());
  os << '\n';

  // need the uppercase version of my name
  std::string upperName = getName();
  //    std::use_facet<std::ctype<char> >(std::locale::classic()).toupper (upperName.begin(), upperName.end());
  // for (std::string::size_type i=0; i<upperName.size(); i++) upperName[i] = toupper(upperName[i]);
  transform (upperName.begin(), upperName.end(), upperName.begin(), toupper);
  
  // C++ specific .hpp file stuff
  {
    os << "namespace gen {\n";
    os << '\n';
    
    // C++ MDat class declaration/definition
    os << "class " << getCPPName() << " : ";
    if (isCtlMsg())
      os << "public CtlMDatBase {\n";
    else
      os << "public MDatCompBase {\n";
      
    os << "public:\n";
    if (isCtlMsg())
      os << "  typedef CtlMDatBase Base;\n";
    else
      os << "  typedef MDatCompBase Base;\n";

    // print out TokInfo
    if (isCtlMsg()) {
      os << "  static TokInfo info_" << keyword << ";\n";
      os << "  keyword_sy getTok() const;\n";
      os << '\n';
    }

    // print out the members
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) 
      if (members[i].getName() != getFlagVarName())
	members[i].printCPPDeclaration (os);
    os << '\n';

    // print out the interface to the members
    printCPPMemberIntDef (os);

    // constructor
    {
      int tmp = 0;
      os << "public:\n"
	 << "  explicit " << getCPPName() << "(";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
	if (!members[i].isConst()) {
	  if (tmp) os << ",";
	  tmp++;
	  os << '\n'
	     << "    " << members[i].getCPPConstRef ()
	     << " " << "_m_"+members[i].getName()
	     << " = " << members[i].getCPPDefaultVal();
	}
      }
      os << '\n' << "  );";
      os << '\n';
    }

    // copy constructor
    {
      os << "public:\n"
	 << "  " << getCPPName() << "(const " << getCPPName() << " & rhs);\n";
    }

    // common constructor init
    {
      os << "private:\n" 
	 << "  void initMemberInfo ();\n";
    }

    // assignment operator
    {
      os << "public:\n"
	 << "  " << getCPPName() << "& operator= (const " << getCPPName() << " & rhs);\n";
    }

    // getMemberName() declared
    os << "public:";
    os << "  const char * getMemberName(size_t i) const;\n";

    // for control mdata, declare and define destructor that throw()
    if (isCtlMsg())
      os << "  virtual ~" << getCPPName() << "() throw();\n";
    else
      os << "  virtual ~" << getCPPName() << "();\n";
    
    // for control mdata, declare and define getStatus() member function
    if (isCtlMsg())
      os << "  int getStatus() const;\n";

    // end of class definition
    os << "};\n";
    os << '\n';

    // Inclusion (HPP)
    if (incInfo.hasInclusion(InclusionInfo::INC_HPP)) {
      incInfo.printInclusion (os, InclusionInfo::INC_HPP);
      os << '\n';
    }
    
    os << "} // namespace gen\n";
  }

}

void MDataTypeInfo::printCPPMemberIntDef (std::ostream & os) const {
  // do we have msg_flags variable?
  std::string msgFlagVarName = getName() + "_msg_flags";
  bool haveMsgFlagsVar = false;
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
    if ( (!members[i].isConst()) && (members[i].getName() == msgFlagVarName) ) {
      haveMsgFlagsVar = true; break;
    }
  // print out member interfaces
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
    std::string flagConstName = "MSG_FLAGS_" + members[i].getName();
    transform (flagConstName.begin(), flagConstName.end(), flagConstName.begin(), toupper);
    bool autoSetMsgFlags = false;
    if (haveMsgFlagsVar) {
      for (std::vector<MDataMemberInfo>::size_type j=0; j<members.size(); j++)
	if ( (members[j].isConst()) && (members[j].getName() == flagConstName) ) {
	  autoSetMsgFlags = true; break;
	}
    }
    if (!members[i].isConst())
      members[i].printCPPIntDef (os, autoSetMsgFlags, msgFlagVarName, flagConstName);
  }
}

void MDataTypeInfo::printCDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C Definition for mdata " + getName());
  os << '\n';

  std::string upperName = getName();
  transform (upperName.begin(), upperName.end(), upperName.begin(), toupper);

  // C mdat_create definition
  {
    os << "rcode_sy " << "mdat_create_"+getName() 
       << " (char_sy ** bs_pp, const char_sy * be_p, const " << getCName() << " *dat_p)\n"
       << "{\n";
    int maxLoopVarCount = 0;
    int errCodeCount = 3;
    std::strstream tmpOut;
//    if (!isInner()) 
//      tmpOut << "  if (TOK_putreqid( &bc_p, (char_sy *) be_p, dat_p->reqid) < 0 ) return (-" 
//	     << errCodeCount++ << ");\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
	int loopVarCount = 0;
	members[i].printCTokPut (tmpOut, "bc_p", "be_p", "dat_p", 
				 loopVarCount, errCodeCount,
				 "dat_p->"+members[i].getName(), members[i].typeQuals.size() );
	if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
      }
    tmpOut << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (members[i].typePtr->isLink()) 
	os << "  " << members[i].typePtr->getCName() << " * _" << members[i].getName() << "_ptr;\n";
    os << "  char_sy *bc_p; /* message current ptr */\n"
       << "  bc_p = *bs_pp; /* initialize current ptr */\n"
       << "  if (ssdebug>=mdat_x_glob.debug_base_create) {\n"
       << "    msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"mdat_create_" << getName() <<"\");\n"
       << "    mdat_print_" << getName() << " (dat_p, \"dat_p\");\n"
       << "  }\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  *bs_pp = bc_p;\n"
       << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_parse definition
  {
    os << "rcode_sy " << "mdat_parse_"+getName() 
       << " (const char_sy **bs_pp, " << getCName() << " *dat_p";
    if (b_ParserUsesMSList) os << ", short_sy mem_hndl";
    os << ")\n"
       << "{\n";
    int maxLoopVarCount = 0;
    int errCodeCount = 3;
    std::strstream tmpOut;
//    if (!isInner()) 
//      tmpOut << "  if (TOK_getreqid( (char_sy **) &bc_p, &dat_p->reqid)) return (-" 
//	     << errCodeCount++ << ");\n";
    std::vector<std::string> usedLenNames;
    bool useTmp = false;
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
	int loopVarCount = 0;
	members[i].printCTokGet (tmpOut, "bc_p", "mem_hndl", "dat_p",
				 loopVarCount, errCodeCount ,
				 usedLenNames, useTmp,
				 "dat_p->"+members[i].getName(), members[i].typeQuals.size() );
	if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
      }
    if (isLink()) tmpOut << "  dat_p->" << linkVar << " = NULL;\n";
    tmpOut << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    if (useTmp) os << "  short_sy tmp;\n";
    os << "  const char_sy *bc_p; /* message current ptr */\n"
       << "  bc_p = *bs_pp; /* initialize current ptr */\n"
       << "  if (ssdebug>=mdat_x_glob.debug_base_parse)\n"
       << "    msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"mdat_parse_" << getName() <<"\");\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  *bs_pp = bc_p;\n"
       << "  if (ssdebug>=mdat_x_glob.debug_base_parse)\n"
       << "    mdat_print_" << getName() << " (dat_p, \"dat_p\");\n"
       << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_copy definition
  {
    os << "rcode_sy " << "mdat_copy_"+getName() 
       << " (" << getCName() << " * copy_p, const " << getCName() << " * orig_p";
    if (b_ParserUsesMSList) os << ", short_sy mem_hndl";
    os << ")\n"
       << "{\n";
    int maxLoopVarCount = 0;
    std::strstream tmpOut;
    if (!isInner()) 
      tmpOut << "  copy_p->reqid = orig_p->reqid;\n";
    std::vector<std::string> usedLenNames;
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
	int loopVarCount = 0;
	members[i].printCCopy (tmpOut, "copy_p", "orig_p", "mem_hndl", 
			       loopVarCount, usedLenNames, 
			       "copy_p->"+members[i].getName(), 
			       "orig_p->"+members[i].getName(), 
			       members[i].typeQuals.size() );
	if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
      }
    if (isLink()) tmpOut << "  copy_p->" << linkVar << " = NULL;\n";
    tmpOut << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    os << "  if (ssdebug>=mdat_x_glob.debug_base_copy)\n"
       << "    msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"mdat_copy_" << getName() <<"\");\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_ostrm_print definition
  {
    os << "rcode_sy " << "mdat_ostrm_print_"+getName() 
       << " (mdat_ostrm_t * os_p, const " << getCName() << " * dat_p, const char * name)\n"
       << "{\n";
    int maxLoopVarCount = 0;
    std::strstream tmpOut;

    tmpOut << "  if ((rc=mdat_ostrm_print_mdata_begin (os_p, name, \"" << getCName() << "\")))\n"
           << "    { if (rc!=MDAT_OSTRM_ERR_LEVEL_TOO_DEEP) return rc; }\n"
           << "  else\n"
           << "    {\n";
    if (!isInner()) 
      tmpOut << "      if ((rc=mdat_ostrm_print_REQID_ (os_p, dat_p->reqid, \"reqid\"))) return rc;\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
        if (members[i].isHidden()) {
          tmpOut << "      if ((rc=mdat_ostrm_x_print_primitive (os_p, \"...\", \"" 
                 << members[i].getName() << "\", \"...\"))) return rc;\n"<< std::endl;
	} else {
	  int loopVarCount = 0;
	  members[i].printCOstrmPrint (tmpOut, "os_p", "dat_p", loopVarCount, "\"" + members[i].getName() + "\"",
				       "dat_p->"+members[i].getName(), members[i].typeQuals.size() );
	  if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
	}
      }
    tmpOut << "      if ((rc=mdat_ostrm_print_mdata_end (os_p))) return rc;\n"
	   << "    }\n" << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (members[i].typePtr->isLink()) 
	os << "  " << members[i].typePtr->getCName() << " * _" << members[i].getName() << "_ptr;\n";
    os << "  rcode_sy rc;\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_stree_put definition
  {
    os << "rcode_sy " << "mdat_stree_put_"+getName() 
       << " (stree_t * stree, const " << getCName() << " * dat_p, const char * name)\n"
       << "{\n";
    int maxLoopVarCount = 0;
    std::strstream tmpOut;

    tmpOut << "  if (!name) name = \"" << getName() << "\";\n"
	   << "  if ((rc=mdat_stree_put_mdata_begin (stree, name)))\n"
           << "    return rc;\n"
           << "  else\n"
           << "    {\n";
    if (!isInner()) 
      tmpOut << "      if ((rc=mdat_stree_put_REQID_ (stree, dat_p->reqid, \"reqid\"))) return rc;\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
	int loopVarCount = 0;
	members[i].printCSTreePut (tmpOut, "stree", "dat_p", loopVarCount, "\"" + members[i].getName() + "\"",
				     "dat_p->"+members[i].getName(), members[i].typeQuals.size() );
	if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
      }
    tmpOut << "      if ((rc=mdat_stree_put_mdata_end (stree))) return rc;\n"
	   << "    }\n" << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (members[i].typePtr->isLink()) 
	os << "  " << members[i].typePtr->getCName() << " * _" << members[i].getName() << "_ptr;\n";
    os << "  rcode_sy rc;\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_stree_get definition
  {
    os << "rcode_sy " << "mdat_stree_get_"+getName() 
       << " (stree_t * stree, " << getCName() << " * dat_p, const char * name, short_sy mem_hndl)\n"
       << "{\n";
    int maxLoopVarCount = 0;
    std::strstream tmpOut;

    tmpOut << "  if (!name) name = \"" << getName() << "\";\n"
	   << "  if ((rc=mdat_stree_get_mdata_begin (stree, name)))\n"
	   << "    {if (rc!=STREE_ERR_INVALID_KEY) return rc;}\n"
           << "  else\n"
           << "    {\n";
    if (!isInner()) 
      tmpOut << "      if ((rc=mdat_stree_get_REQID_ (stree, &dat_p->reqid, \"reqid\"))) return rc;\n";
    std::vector<std::string> usedLenNames;
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (!members[i].isConst()) {
	int loopVarCount = 0;
	members[i].printCSTreeGet (tmpOut, "stree", "dat_p", "mem_hndl", 
				   loopVarCount, usedLenNames, "\"" + members[i].getName() + "\"",
				   "dat_p->"+members[i].getName(), members[i].typeQuals.size() );
	if (loopVarCount > maxLoopVarCount) maxLoopVarCount = loopVarCount;
      }
    tmpOut << "      if ((rc=mdat_stree_get_mdata_end (stree))) return rc;\n"
	   << "    }\n" << std::ends;
    for (int i=0; i<maxLoopVarCount; i++) os << "  long i_" << i << ";\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (members[i].typePtr->isLink()) 
	os << "  " << members[i].typePtr->getCName() << " * _" << members[i].getName() << "_ptr;\n";
    os << "  rcode_sy rc;\n";
    os << tmpOut.str(); tmpOut.freeze(false);
    os << "  return (0);\n"
       << "}\n";
  }
  os << '\n';

  // C mdat_print definition
  {
    os << "mdat_print_impl_def(" << "mdat_print_"+getName() 
       << " (const " << getCName() << " * dat_p, const char * name), ostrm_p,\n"
       << "  mdat_ostrm_print_" << getName() << " (ostrm_p, dat_p, name))\n";
  }

  // if control mdat, C msg_create/parse functions definitions
  if (isCtlMsg())
    {
      // msg_create definition
      os << "long_sy " << "msg_create_"+getName()
	 << " (const " << getCName() << " *sp, char_sy *bs, const char_sy *be)\n"
	 << "  {\n"
	 << "    rcode_sy rc;\n"
	 << "    char_sy * cp;\n"
	 << "    cp = bs;\n"
	 << "    if (ssdebug>=svc_x_glob.debug_base_msg_create) {\n"
	 << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"msg_create_" << getName() <<"\");\n"
	 << "      mdat_print_keyword_sy_ (" << keyword << ", \"keyword\");\n"
	 << "    }\n"
	 << "    if (TOK_putkeyword(&cp, (char_sy *) be, " << keyword << ") < 0) return(-1);\n"
	 << "    if (TOK_putreqid(&cp, (char_sy *) be, sp->reqid) < 0) return(-2);\n"
	 << "    if ((rc = mdat_create_"+getName() << " (&cp, be, sp)) < 0)\n"
	 << "      return rc;\n"
	 << "    return (cp-bs);\n"
	 << "  }\n";
      // msg_parse definition
      os << "rcode_sy " << "msg_parse_"+getName() << " (const char_sy *bs, " << getCName() << " *sp";
      if (parserUsesMSList()) os << ", short_sy mem_hndl";
      os << ")\n"
	 << "  {\n"
	 << "    const char_sy * cp;\n"
	 << "    cp = bs;\n"
	 << "    if (ssdebug>=svc_x_glob.debug_base_msg_parse)\n"
	 << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"msg_parse_" << getName() <<"\");\n"
	 << "    if (TOK_getreqid((char_sy **)&cp, &sp->reqid)) return(-2);\n"
	 << "    return (mdat_parse_"+getName() << " (&cp, sp";
      if (parserUsesMSList()) os << ", mem_hndl";
      os <<"));\n"
	 << "  }\n";
    }

    // if not inner mdat, C mdat_msg_create/parse functions definitions
    if (!isInner())
      {
	// mdat_msg_create definition
	os << "long_sy " << "mdat_msg_create_"+getName() 
	   << " (const " << getCName() << " *sp, char_sy *bs, const char_sy *be, keyword_sy msgcode)\n"
	   << "  {\n"
	   << "    rcode_sy rc;\n"
	   << "    char_sy * cp;\n"
	   << "    cp = bs;\n"
	   << "    if (ssdebug>=mdat_x_glob.debug_base_msg_create) {\n"
	   << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"mdat_msg_create_" << getName() <<"\");\n"
	   << "      mdat_print_keyword_sy_ (msgcode, \"keyword\");\n"
	   << "    }\n"
	   << "    if (TOK_putkeyword(&cp, (char_sy *) be, msgcode) < 0) return(-1);\n"
	   << "    if (TOK_putreqid(&cp, (char_sy *) be, sp->reqid) < 0) return(-2);\n"
	   << "    if ((rc = mdat_create_"+getName() << " (&cp, be, sp)) < 0)\n"
	   << "      return rc;\n"
	   << "    return (cp-bs);\n"
	   << "  }\n";
	// mdat_msg_parse definition
	os << "rcode_sy " << "mdat_msg_parse_"+getName() << " (const char_sy *bs, " << getCName() << " *sp";
	if (parserUsesMSList()) os << ", short_sy mem_hndl";
	os << ", keyword_sy msgcode)\n"
	   << "  {\n"
	   << "    const char_sy * cp;\n"
	   << "    keyword_sy msgcode_in;\n"
	   << "    if (ssdebug>=mdat_x_glob.debug_base_msg_parse)\n"
	   << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"mdat_msg_parse_" << getName() <<"\");\n"
	   << "    cp = bs;\n"
	   << "    if (msgcode) {\n"
	   << "      if (ssdebug>=mdat_x_glob.debug_base_msg_parse)\n"
	   << "        mdat_print_keyword_sy_ (msgcode, \"keyword\");\n"
	   << "      if (TOK_getkeyword((char_sy **)&cp, &msgcode_in)) return (-1);\n"
	   << "      if (msgcode_in != msgcode) return (MS_MESSAGE_ID_PARSE_ERROR);\n"
	   << "    }\n"
	   << "    if (TOK_getreqid((char_sy **)&cp, &sp->reqid)) return(-2);\n"
	   << "    return (mdat_parse_"+getName() << " (&cp, sp";
	if (parserUsesMSList()) os << ", mem_hndl";
	os <<"));\n"
	   << "  }\n";
      }
}

void MDataTypeInfo::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for mdata " + getName());
  os << '\n';

  std::string upperName = getName();
  transform (upperName.begin(), upperName.end(), upperName.begin(), toupper);

  {
    os << "namespace gen {\n";
    os << '\n';
    
    // static consts
    {
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) 
	if (members[i].isConst()) {
	  os << "const " << members[i].getCPPQualTypeName() << " " << getCPPName() << "::" << members[i].getName()
	     << " = " << members[i].getCPPDefaultVal() << ";\n";
	}
      os << '\n';
    }

    // TokInfo
    if (isCtlMsg()) {
      os << "TokInfo " << getCPPName() << "::info_" << keyword << " (\"" << keyword << "\");\n";
      os << "keyword_sy " << getCPPName() << "::getTok() const { return info_" << keyword << ".getVal();}\n";
      os << '\n';
    }
    
    // constructor
    {
      int tmp = 0;
      os << getCPPName() << "::" << getCPPName() << "(";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	{
	  if (!members[i].isConst()) {
	    if (tmp) os << ",";
	    tmp++;
	    os << '\n'
	       << "    " << members[i].getCPPConstRef ()
	       << " " << "_m_"+members[i].getName();
	  }
	}
      os << '\n' << "  ) : Base(\"" << getName() << "\"";
      if (b_IsFormat) os << ", " << getFormatString();
      os << ")\n";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (!members[i].isConst())
	  os << "  , " << members[i].getName() << " (" << "_m_"+members[i].getName() << ")\n";
      os << " {initMemberInfo();}\n";
      os << '\n';
    }

    // destructor
    {
      if (isCtlMsg())
	os << getCPPName() << "::~" << getCPPName() << "() throw () {}\n";
      else
	os << getCPPName() << "::~" << getCPPName() << "() {}\n";
      os << '\n';
    }

    // copy constructor
    {
      int tmp = 0;
      os << getCPPName() << "::" << getCPPName() << "(const " << getCPPName() << " & _rhs) \n";
      os << "  : Base(\"" << getName() << "\"";
      if (b_IsFormat) os << ", " << getFormatString();
      os << ")\n";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (!members[i].isConst())
	  os << "  , " << members[i].getName() << " (_rhs."+members[i].getName() << ")\n";
      os << " {initMemberInfo();}\n";
      os << '\n';
    }

    // common constructor init
    {
      os << "void " << getCPPName() << "::initMemberInfo () ";
      os << " {\n";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (!members[i].isConst()) {
	  os << "    newMember(" << members[i].getName();
	  if (members[i].isHidden()) {
	    os << ",true";
	  }
	  os << ");\n";
	}
      os << "}\n\n";
    }

    // assignment operator
    {
      os << getCPPName() << "& " << getCPPName() << "::operator= (const " << getCPPName() << " & _rhs) {\n";
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (!members[i].isConst())
	  os << "  " << members[i].getName() << " = _rhs."+members[i].getName() << ";\n";
      os << "  return *this;"
	 << "}\n\n";
    }

    // getMemberName() implementation
    {
      int count = 0;
      for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	if (!members[i].isConst()) ++count;
      int tmp = 0;
      os << "const char * " << getCPPName() << "::getMemberName(size_t i) const {\n";
      if (count) {
	os << "  static const char * memberNames[] = {\n";
	for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
	  if (!members[i].isConst()) {
	    if (tmp) os << "    , ";
	    else     os << "      ";
	    tmp++;
	    os << "\"" << members[i].getName() << "\"\n";
	  }
	os << "  };\n";
	os << "  if ( (i<0) || (i >= (sizeof (memberNames)/ sizeof (char *)) ) ) return 0;\n";
	os << "  return memberNames[i];\n";
      } else {
	os << "  return NULL;\n";
      }
      os << "}\n";
      os << '\n';
    }

    // for control mdata, define getStatus() member function
    if (isCtlMsg())
      os << "int " << getCPPName() << "::getStatus() const {return " << getCtlVar() << ";}\n";

    // Inclusion (CPP)
    if (incInfo.hasInclusion(InclusionInfo::INC_CPP)) {
      incInfo.printInclusion (os, InclusionInfo::INC_CPP);
      os << '\n';
    }
    
    os << "} // namespace gen\n";
  }

}

void MDataTypeInfo::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os)
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n";
  os << '\n';

  codeDelim _cd(os, "Java Definition for mdata " + getName());
  os << '\n';

  // begin message data class definition
  os << "public class " << getJName() << " extends msgBase {\n";

  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  // class name std::string
  os << "  private static final String _name=\"" << getJName() << "\";\n";
  // display field index
  os << "  private static final int _dispFieldIdx=" << dispMemberIdx << ";\n";
  os << '\n';

  // field signature definition
  {
    int tmp = 0;
    os << "  private static final String[] _signature={";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
      if (!members[i].isConst()) {
	if (tmp) os << ",";
	tmp++;
	os << '\n';
	os << "    ";
	os << "\"";
	std::string outTok = members[i].getTypePtr()->getJTok();
	for (std::vector<TypeQualifier>::size_type j = 0; j < members[i].typeQuals.size(); j++)
	  if (members[i].typeQuals[j].isVarArray())
	    {
	      if (j==0) 
		outTok = members[i].getTypePtr()->getJArrayTok();
	      else
		outTok = "[" + outTok;
	      // outTok = "Ljava/util/Vector;";
	    }
	  else if (members[i].typeQuals[j].isFixedArray())
	    outTok = "[" + outTok;
	  else if (members[i].typeQuals[j].isPtr())
	    outTok = outTok + "*";
	os << outTok;
	os << "\"";
      }
    }
    os << '\n';
    os << "  };\n";
  }

  // field memberNames definition
  {
    int tmp = 0;
    os << "  private static final String[] _memberNames={";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
      if (!members[i].isConst()) {
	if (tmp) os << ",";
	tmp++;
	os << '\n'
	   << "    \"" << members[i].getName() << "\"";
      }
    }
    os << '\n';
    os << "  };\n";
  }

  // visual components definition
  {
    int tmp = 0;
    os << "  private static final String[] _vtypes={";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
      if (!members[i].isConst()) {
	if (tmp) os << ",";
	tmp++;
	os << '\n';
	os << "    \"" << members[i].visInfo.vType << "\"";
      }
    }
    os << '\n';
    os << "  };\n";
  }
  
  // URI's definition
  {
    int tmp = 0;
    os << "  private static final String[] _uris={";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
      if (!members[i].isConst()) {
	if (tmp) os << ",";
	tmp++;
	os << '\n'
	   << "    " << members[i].visInfo.vURI;
      }
    }
    os << '\n'
       << "  };\n";
  }
  
  // scripts definition
  {
    int tmp = 0;
    os << "  private static final String[] _scripts={";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
      if (!members[i].isConst()) {
	if (tmp) os << ",";
	tmp++;
	os << '\n'
	   << "    " << members[i].visInfo.vFunc;
      }
    }
    os << '\n'
       << "  };\n";
    os << '\n';
  }
  
  // Inclusion (JAVA)
  if (incInfo.hasInclusion(InclusionInfo::INC_JAVA)) {
    incInfo.printInclusion (os, InclusionInfo::INC_JAVA);
    os << '\n';
  }

  // print out the members
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
    members[i].printJDeclaration (os);
  os << '\n';

  // print out the interface to the members
  printJMemberIntDef (os);
  os << '\n';

  // plain constructor 
  os << "  public " << getJName() << "() {};\n";

  // constructor that sets each member
/*
  if (members.size()) {
    os << "  public " << getJName() << "(";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      {
	if (i) os << ",";
	os << '\n'
	   << "        " 
	   << members[i].getJQualTypeName () << " "
	   << "_m_"+members[i].getName();
      }
    os << " ){\n";
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      os << "    " << members[i].getName() << " = " << "_m_"+members[i].getName() << ";\n";
    os << "  };\n";
    os << '\n';
  }
*/

  // constructor that unflattens definition
  os << "  public " << getJName() << "(int tok, byte[] bs) throws marshallingException {\n"
     << "    unflatten(tok, bs);\n"
     << "  };\n";
  os << '\n';

  // copy function (implements memberwise copy)
  os << "  public void copy (" << getJName() << " in ) {\n";
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
    if (!members[i].isConst())
      os << "    " << members[i].getName() << " = in." << members[i].getName() << ";\n";
  os << "  };\n";
  os << '\n';

  os << "}\n";
  os << '\n';
}

void MDataTypeInfo::printJMemberIntDef (std::ostream & os, const std::string & this_str) const {
  // do we have msg_flags variable?
  std::string msgFlagVarName = getName() + "_msg_flags";
  bool haveMsgFlagsVar = false;
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
    if ( (!members[i].isConst()) && (members[i].getName() == msgFlagVarName) ) {
      haveMsgFlagsVar = true; break;
    }
  // print out member interfaces
  for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++) {
    std::string flagConstName = "MSG_FLAGS_" + members[i].getName();
    transform (flagConstName.begin(), flagConstName.end(), flagConstName.begin(), toupper);
    bool autoSetMsgFlags = false;
    if (haveMsgFlagsVar) {
      for (std::vector<MDataMemberInfo>::size_type j=0; j<members.size(); j++)
	if ( (members[j].isConst()) && (members[j].getName() == flagConstName) ) {
	  autoSetMsgFlags = true; break;
	}
    }
    if (!members[i].isConst())
      members[i].printJIntDef (os, this_str, autoSetMsgFlags, msgFlagVarName, flagConstName);
  }
}

bool MDataTypeInfo::isMember (const std::string & _memberName) const {
    for (std::vector<MDataMemberInfo>::size_type i=0; i<members.size(); i++)
      if (_memberName == members[i].getName()) return true;
    return false;
}

//
// MsgSpec implementations
//
MsgSpec::MsgSpec (const std::string & _mDatName, const std::string & _keyword, bool _amVector) : 
  keyword(_keyword), amVector(_amVector) { _init(_mDatName); }

MsgSpec::MsgSpec (const std::string & _mDatName, const std::string & _keyword, const std::string & _vectorSizeName) : 
  keyword(_keyword), amVector(true), vectorSizeName(_vectorSizeName) { _init (_mDatName); }

void MsgSpec::_init (const std::string & _mDatName) {
  mdat_p = MDataTypeInfo::get(_mDatName);
}

void MsgSpec::setID (MsgSpec::Type _type, const std::string & _idName, const std::string & _svcName) {
  type = _type;
  if (type==MsgSpec::DatOrFin) {
    if (mdat_p->isCtlMsg()) type = MsgSpec::Fin;
    else type = MsgSpec::Dat;
  }
  if (type==MsgSpec::Fin) 
    idName = mdat_p->getName();
  else
    idName = _idName;
  if (keyword.empty()) {
    keyword = "TOK_" + idName;
    transform (keyword.begin(), keyword.end(), keyword.begin(), toupper);
  }
  if (type==MsgSpec::Fin) return;
  KeywordTab::get().add(keyword, idName, _svcName);
}

void MsgSpec::printCDecMsg (std::ostream &os) const {
  // msg_create/parse declarations
  if (type==MsgSpec::Fin) return;
  os << "long_sy "  << "msg_create_"+idName 
     << " (const " << mdat_p->getCName() << " *sp, char_sy *bs, const char_sy *be);\n";
  os << "rcode_sy " << "msg_parse_"+idName << " (const char_sy *bs, " << mdat_p->getCName() << " *sp";
  if (mdat_p->parserUsesMSList()) os << ", short_sy mem_hndl";
  os << ");\n";
}

void MsgSpec::printCDefMsg (std::ostream &os) const {
  if (type==MsgSpec::Fin) return;
  // msg_create definition
  os << "long_sy " << "msg_create_"+idName 
     << " (const " << mdat_p->getCName() << " *sp, char_sy *bs, const char_sy *be)\n"
     << "  {\n"
     << "    rcode_sy rc;\n"
     << "    char_sy * cp;\n"
     << "    cp = bs;\n"
     << "    if (ssdebug>=svc_x_glob.debug_base_msg_create) {\n"
     << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"msg_create_" << idName <<"\");\n"
     << "      mdat_print_keyword_sy_ (" << keyword << ", \"keyword\");\n"
     << "    }\n"
     << "    if (TOK_putkeyword(&cp, (char_sy *) be, " << keyword << ") < 0) return(-1);\n"
     << "    if (TOK_putreqid(&cp, (char_sy *) be, sp->reqid) < 0) return(-2);\n"
     << "    if ((rc = mdat_create_"+mdat_p->getName() << " (&cp, be, sp)) < 0)\n"
     << "      return rc;\n"
     << "    return (cp-bs);\n"
     << "  }\n";
  // msg_parse definition
  os << "rcode_sy " << "msg_parse_"+idName << " (const char_sy *bs, " << mdat_p->getCName() << " *sp";
  if (mdat_p->parserUsesMSList()) os << ", short_sy mem_hndl";
  os << ")\n"
     << "  {\n"
     << "    const char_sy * cp;\n"
     << "    cp = bs;\n"
     << "    if (ssdebug>=svc_x_glob.debug_base_msg_parse)\n"
     << "      msg_print (MSG_FUNC_CALL, \"GEN\", 0, \"msg_parse_" << idName <<"\");\n"
     << "    if (TOK_getreqid((char_sy **)&cp, &sp->reqid)) return(-2);\n"
     << "    return (mdat_parse_"+mdat_p->getName() << " (&cp, sp";
  if (mdat_p->parserUsesMSList()) os << ", mem_hndl";
  os <<"));\n"
     << "  }\n";
}


//
// SvcFuncP1 implementations
//

void SvcFuncP1::printCPPDeclaration (std::ostream &os) const {
  os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req)";
}

void SvcFuncP1::printCPPDecTokInfos (std::ostream & os) const {
  os << "  static TokInfo info_" << msgSpecs[0].idName << ";\n";
}
void SvcFuncP1::printCPPDefAddSvcFunc (std::ostream & os, const std::string & _svcName) const {
  os << "  addSvcFunc( new MDatSvcFuncP1" 
     << "<&info_" << msgSpecs[0].idName << ", "
     << msgSpecs[0].mdat_p->getCPPName() << ","
     << "const " << msgSpecs[0].mdat_p->getCPPName() << ", "
     << _svcName << ", &" << _svcName << "::" << getName() << "_> (\"" << getName() << "\", *this));\n";
}

void SvcFuncP1::printCPPDefTokInfos (std::ostream & os, const std::string & _svcName) const {
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[0].idName << " (\"" << msgSpecs[0].idName << "\");\n";
}

void SvcFuncP1::printCPPDecCliSvcMemberFunc (std::ostream & os) const {
  os << "  void " << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req) ;\n";
}

void SvcFuncP1::printCPPDefCliSvcMemberFunc (std::ostream & os, const std::string & classNam) const {
  os << "void " << classNam << "::" << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req) {\n"
     << "  funcP1 (info_" << msgSpecs[0].idName << ".getVal(), _req);\n"
     << "}\n";
}

void SvcFuncP1::printJDefSvc (std::ostream &os) const {
  os << "\tpublic void " << getMangledName() << " ("
     << msgSpecs[0].mdat_p->getJUserName() << " a_in"
     << ") throws cmException, marshallingException;\n";
}

void SvcFuncP1::printJDefSvcInt (std::ostream &os) const {
  os << "\tprivate void __" << getMangledName() << " ("
     << msgSpecs[0].mdat_p->getJUserName() << " a_in"
     << ") throws cmException, marshallingException {\n"
     << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n\n"
     << "\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
     << "\t}\n";
  os << "\tpublic void " << getMangledName() << " ("
     << msgSpecs[0].mdat_p->getJUserName() << " a_in"
     << ") throws cmException, marshallingException {\n"
     << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { __" << getMangledName() << " (a_in); }\n"
     << "\t\telse { __" << getMangledName() << " (a_in); }\n"
     << "\t}\n";
}

void SvcFuncP1::printJDefSvcImp (std::ostream &os) const {
  os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
     << "\t\t\t{\n"
     << "\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
     << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
     << ",inBytes);\n"
     << "\t\t\t\t_svcRef." << getMangledName() << "(a_in);\n"
     << "\t\t\t\treturn true;\n"
     << "\t\t\t}\n";
}

void SvcFuncP1::printJDefEnv (std::ostream &os, const std::vector<bool> & flagMatched,
			      const std::vector<std::vector<MsgSpec>::size_type> & idxMatched,
			      const std::vector<EnvArg> & envArgs) const {
  if (flagMatched[0]) // the only argument is hidden
    {
      os << "\tpublic void " << getMangledName() << " () throws cmException, marshallingException {\n"
	 << "\t\t_svcRef." << getMangledName() << "(";
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
      os << ");\n"
	 << "\t}\n";
    }
  else
    {
      os <<"\tpublic void " << getMangledName() << " (" 
	 << msgSpecs[0].mdat_p->getJUserName() << " a_in) throws cmException, marshallingException {\n"
	 << "\t\t_svcRef." << getMangledName() << "(a_in);\n"
	 << "\t}\n";
    }
}

//
// SvcFuncP2 implementations
//

void SvcFuncP2::printCPPDeclaration (std::ostream &os) const {
  if (msgSpecs[1].mdat_p->isCtlMsg())
    os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req)";
  else
    os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
       << msgSpecs[1].mdat_p->getCPPName() << " & _dat)";
}

void SvcFuncP2::printCPPDecTokInfos (std::ostream & os) const {
  os << "  static TokInfo info_" << msgSpecs[0].idName << ";\n";
  if (!msgSpecs[1].mdat_p->isCtlMsg())
    os << "  static TokInfo info_" << msgSpecs[1].idName << ";\n";
}
void SvcFuncP2::printCPPDefAddSvcFunc (std::ostream & os, const std::string & _svcName) const {
  os << "  addSvcFunc( new MDatSvcFuncP2";
  if (msgSpecs[1].mdat_p->isCtlMsg()) os << 'X';
  os << "<&info_" << msgSpecs[0].idName << ", "
     << msgSpecs[0].mdat_p->getCPPName() << ", "
     << "const " << msgSpecs[0].mdat_p->getCPPName() << ", ";
  if (!msgSpecs[1].mdat_p->isCtlMsg()) 
  os << "&info_" << msgSpecs[1].idName << ", ";
  os << msgSpecs[1].mdat_p->getCPPName() << ", "
     << _svcName << ", &" << _svcName << "::" << getName() << "_> (\"" << getName() << "\", *this));\n";
}

void SvcFuncP2::printCPPDefTokInfos (std::ostream & os, const std::string & _svcName) const {
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[0].idName << " (\"" << msgSpecs[0].idName << "\");\n";
  if (!msgSpecs[1].mdat_p->isCtlMsg())
    os << "TokInfo " << _svcName << "::info_" << msgSpecs[1].idName << " (\"" << msgSpecs[1].idName << "\");\n";
}


void SvcFuncP2::printCPPDecCliSvcMemberFunc (std::ostream & os) const {
  if (msgSpecs[1].mdat_p->isCtlMsg()) {
    os << "  void " << getName() << "_ ("
       << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req);\n";
  } else {
    os << "  void " << getName() << "_ ("
       << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
       << msgSpecs[1].mdat_p->getCPPName() << " & _dat);\n";
  }
}

void SvcFuncP2::printCPPDefCliSvcMemberFunc (std::ostream & os, const std::string & classNam) const {
  if (msgSpecs[1].mdat_p->isCtlMsg()) {
    os << "void " << classNam << "::" << getName() << "_ ("
       << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req) {\n"
       << "  " << msgSpecs[1].mdat_p->getCPPName() << " fin;\n"
       << "  funcP2X (info_" << msgSpecs[0].idName << ".getVal(), _req, fin);\n"
       << "  if (fin.getStatus()) throw fin;\n"
       << "}\n";
  } else {
    os << "void " << classNam << "::" << getName() << "_ ("
       << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
       << msgSpecs[1].mdat_p->getCPPName() << " & _dat) {\n"
       << "  funcP2 (info_" << msgSpecs[0].idName << ".getVal(), _req,\n"
       << "          info_" << msgSpecs[1].idName << ".getVal(), _dat);\n"
       << "}\n";
  }
}

void SvcFuncP2::printJDefSvc (std::ostream &os) const {
  if (msgSpecs[1].mdat_p->isCtlMsg())
    {
      os << "\tpublic void " << getMangledName() << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException, bexException;\n";
    }
  else
    {
      os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << " " << getMangledName()
	 << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException;\n";
    }
}
void SvcFuncP2::printJDefSvcInt (std::ostream &os) const {
  if (msgSpecs[1].mdat_p->isCtlMsg())
    {
      os << "\tprivate void __" << getMangledName() << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException, bexException {\n"
	 << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n"
	 << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n\n"
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
	 << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
	 << "\t\t" << msgSpecs[1].mdat_p->getJUserName() << " r = new " << msgSpecs[1].mdat_p->getJUserName() 
	 << "(tok2,cmRef.recvRecord());\n"
	 << "\t\tif (r." << msgSpecs[1].mdat_p->getCtlVar() 
	 << "!=0) throw (new bexException (r, r." << msgSpecs[1].mdat_p->getCtlVar() << "));\n"
	 << "\t}\n";
      os << "\tpublic void " << getMangledName() << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException, bexException {\n"
	 << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { __" << getMangledName() << " (a_in); }\n"
	 << "\t\telse { __" << getMangledName() << " (a_in); }\n"
	 << "\t}\n";
    }
  else
    {
      os << "\tprivate " << msgSpecs[1].mdat_p->getJUserName() << " __" << getMangledName()
	 << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException {\n"
	 << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n"
	 << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n\n"
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
	 << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
	 << "\t\treturn new " << msgSpecs[1].mdat_p->getJUserName() << "(tok2,cmRef.recvRecord());\n"
	 << "\t}\n";
      os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << " " << getMangledName()
	 << " (" << msgSpecs[0].mdat_p->getJUserName() 
	 << " a_in) throws cmException, marshallingException {\n"
	 << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { return __" << getMangledName() << " (a_in); }\n"
	 << "\t\telse { return __" << getMangledName() << " (a_in); }\n"
	 << "\t}\n";
    }
}

void SvcFuncP2::printJDefSvcImp (std::ostream &os) const {
  if (msgSpecs[1].mdat_p->isCtlMsg())
    {
      os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
	 << "\t\t\t{\n"
	 << "\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " r=new " 
	 << msgSpecs[1].mdat_p->getJUserName() << "();\n"
	 << "\t\t\t\ttry {\n"
	 << "\t\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
	 << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
	 << ",inBytes);\n"
	 << "\t\t\t\t\t_svcRef." << getMangledName() << "(a_in);\n"
	 << "\t\t\t\t\tr." << msgSpecs[1].mdat_p->getCtlVar() << "=0;\n"
	 << "\t\t\t\t\t}\n"
	 << "\t\t\t\tcatch( bexException bEx ) {\n"
	 << "\t\t\t\t\tif (" << msgSpecs[1].mdat_p->getJUserName() << ".class.isInstance(bEx.getCtlMDat())) r=(" 
	 << msgSpecs[1].mdat_p->getJUserName() << ") bEx.getCtlMDat();\n"
	 << "\t\t\t\t\tr." << msgSpecs[1].mdat_p->getCtlVar() << "= (short) bEx.rCode;\n"
	 << "\t\t\t\t\t}\n"
	 << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
	 << "\t\t\t\treturn true;\n"
	 << "\t\t\t}\n";
    }
  else
    {
      os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
	 << "\t\t\t{\n"
	 << "\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
	 << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
	 << ",inBytes);\n"
	 << "\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " r=_svcRef." << getMangledName() << "(a_in);\n"
	 << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
	 << "\t\t\t\treturn true;\n"
	 << "\t\t\t}\n";
    }
}

void SvcFuncP2::printJDefEnv (std::ostream &os, const std::vector<bool> & flagMatched,
			      const std::vector<std::vector<MsgSpec>::size_type> & idxMatched,
			      const std::vector<EnvArg> & envArgs) const {
  os << "\tpublic ";
  if ((flagMatched[1]) || (msgSpecs[1].mdat_p->isCtlMsg()) )
    os << "void ";
  else os << msgSpecs[1].mdat_p->getJUserName() << " ";
  os << getMangledName() << " (";
  if (!flagMatched[0]) os << msgSpecs[0].mdat_p->getJUserName() << " a_in";
  os << ") throws cmException, marshallingException";
  if (msgSpecs[1].mdat_p->isCtlMsg()) os << ", bexException";
  os << " {\n";
  if ((flagMatched[1]) || (msgSpecs[1].mdat_p->isCtlMsg()) )
    os << "\t\t";
  else os << "\t\treturn ";
  os << "_svcRef." << getMangledName() << "(";
  if (flagMatched[0])
    {
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
    }
  else os << "a_in";
  os << ");\n"
     << "\t}\n";
}

//
// SvcFuncP3 implementations
//

void SvcFuncP3::printCPPDeclaration (std::ostream &os) const {
  os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << msgSpecs[1].mdat_p->getCPPName() << " & _dat)";
}

void SvcFuncP3::printCPPDecTokInfos (std::ostream & os) const {
  os << "  static TokInfo info_" << msgSpecs[0].idName << ";\n";
  os << "  static TokInfo info_" << msgSpecs[1].idName << ";\n";
}
void SvcFuncP3::printCPPDefAddSvcFunc (std::ostream & os, const std::string & _svcName) const {
  os << "  addSvcFunc(new MDatSvcFuncP3X";
  os << "<&info_" << msgSpecs[0].idName << ", "
     << msgSpecs[0].mdat_p->getCPPName() << ", "
     << "const " << msgSpecs[0].mdat_p->getCPPName() << ", "
     << "&info_" << msgSpecs[1].idName << ", " << msgSpecs[1].mdat_p->getCPPName() << ", "
     << msgSpecs[2].mdat_p->getCPPName() << ", "
     << _svcName << ", &" << _svcName << "::" << getName() << "_> (\"" << getName() << "\", *this));\n";
}

void SvcFuncP3::printCPPDefTokInfos (std::ostream & os, const std::string & _svcName) const {
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[0].idName << " (\"" << msgSpecs[0].idName << "\");\n";
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[1].idName << " (\"" << msgSpecs[1].idName << "\");\n";
}

void SvcFuncP3::printCPPDecCliSvcMemberFunc (std::ostream & os) const {
  os << "  void " << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << msgSpecs[1].mdat_p->getCPPName() << " & _dat);\n";
}

void SvcFuncP3::printCPPDefCliSvcMemberFunc (std::ostream & os, const std::string & classNam) const {
  os << "void " << classNam << "::" << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << msgSpecs[1].mdat_p->getCPPName() << " & _dat) {\n"
     << "  " << msgSpecs[2].mdat_p->getCPPName() << " fin;\n"
     << "  funcP3X (info_" << msgSpecs[0].idName << ".getVal(), _req,\n"
     << "           info_" << msgSpecs[1].idName << ".getVal(), _dat, fin);\n"
     << "  if (fin.getStatus()) throw fin;\n"
     << "}\n";
}

void SvcFuncP3::printJDefSvc (std::ostream &os) const {
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << " " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in) throws cmException, marshallingException, bexException;\n";
}

void SvcFuncP3::printJDefSvcInt (std::ostream &os) const {
  os << "\tprivate " << msgSpecs[1].mdat_p->getJUserName() << " __" << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in) throws cmException, marshallingException, bexException {\n"
     << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n"
     << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n"
     << "\t\tfinal int tok3=com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << ";\n\n"
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
     << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
     << "\t\tbyte[] outBytes=cmRef.recvRecord();\n"
     << "\t\tif (cmRef.getToken()==tok3) {\n"
     << "\t\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r = new " 
     << msgSpecs[2].mdat_p->getJUserName() << "(tok3,outBytes);\n"
     << "\t\t\tthrow (new bexException (r, r." << msgSpecs[2].mdat_p->getCtlVar() << "));\n"
     << "\t\t\t}\n"
     << "\t\t" << msgSpecs[1].mdat_p->getJUserName() << " a_out = new " 
     << msgSpecs[1].mdat_p->getJUserName() << "(tok2,outBytes);\n"
     << "\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r = new " 
     << msgSpecs[2].mdat_p->getJUserName() << "(tok3,cmRef.recvRecord());\n"
     << "\t\tif (r." << msgSpecs[2].mdat_p->getCtlVar() << "!=0) throw (new bexException(r, r."
     << msgSpecs[2].mdat_p->getCtlVar() << "));\n"
     << "\t\treturn a_out;\n"
     << "\t}\n";
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << " " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in) throws cmException, marshallingException, bexException {\n"
     << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { return __" << getMangledName() << " (a_in); }\n"
     << "\t\telse { return __" << getMangledName() << " (a_in); }\n"
     << "\t}\n";
}

void SvcFuncP3::printJDefSvcImp (std::ostream &os) const {
  os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
     << "\t\t\t{\n"
     << "\t\t\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r=new " << msgSpecs[2].mdat_p->getJUserName() << "();\n"
     << "\t\t\t\ttry {\n"
     << "\t\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
     << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
     << ",inBytes);\n"
     << "\t\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " a_out=_svcRef." << getMangledName() << "(a_in);\n"
     << "\t\t\t\t\tcmRef.sendRecord(a_out.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcatch( bexException bEx ) {\n"
     << "\t\t\t\t\tif (" << msgSpecs[2].mdat_p->getJUserName() << ".class.isInstance(bEx.getCtlMDat())) r=(" 
     << msgSpecs[2].mdat_p->getJUserName() << ") bEx.getCtlMDat();\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "= (short) bEx.rCode;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << "));\n"
     << "\t\t\t\treturn true;\n"
     << "\t\t\t}\n";
}

void SvcFuncP3::printJDefEnv (std::ostream &os, const std::vector<bool> & flagMatched,
			      const std::vector<std::vector<MsgSpec>::size_type> & idxMatched,
			      const std::vector<EnvArg> & envArgs) const {
  os << "\tpublic ";
  if (flagMatched[1]) os << "void ";
  else os << msgSpecs[1].mdat_p->getJUserName() << " ";
  os << getMangledName() << " (";
  if (!flagMatched[0]) os << msgSpecs[0].mdat_p->getJUserName() << " a_in";
  os << ") throws cmException, marshallingException, bexException {\n";
  if (flagMatched[1]) 
    {
      if (envArgs[idxMatched[1]].getVarName().empty())
	os << "\t\tcopy( ";
      else
	os << "\t\t" << envArgs[idxMatched[1]].getVarName() << " = ";
    }
  else os << "\t\treturn ";
  os << "_svcRef." << getMangledName() << "(";
  if (flagMatched[0])
    {
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
    }
  else os << "a_in";
  os << ")";
  if (flagMatched[1]) 
    {
      if (envArgs[idxMatched[1]].getVarName().empty())
	os << ");\n";
      else
	os << ";\n";
    }
  else
    os << ";\n";
  os << "\t}\n";
}

//
// SvcFuncP3V implementations
//

void SvcFuncP3V::printCPPDeclaration (std::ostream &os) const {
  os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it)";
}

void SvcFuncP3V::printCPPDecTokInfos (std::ostream & os) const {
  os << "  static TokInfo info_" << msgSpecs[0].idName << ";\n";
  os << "  static TokInfo info_" << msgSpecs[1].idName << ";\n";
}
void SvcFuncP3V::printCPPDefAddSvcFunc (std::ostream & os, const std::string & _svcName) const {
  os << "  addSvcFunc(new MDatSvcFuncP3VX";
  os << "<&info_" << msgSpecs[0].idName << ", "
     << msgSpecs[0].mdat_p->getCPPName() << ", "
     << "const " << msgSpecs[0].mdat_p->getCPPName() << ", "
     << "&info_" << msgSpecs[1].idName << ", " << msgSpecs[1].mdat_p->getCPPName() << ", "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << ">, "
     << msgSpecs[2].mdat_p->getCPPName() << ", "
     << _svcName << ", &" << _svcName << "::" << getName() << "_> (\"" << getName() << "\", *this));\n";
}

void SvcFuncP3V::printCPPDefTokInfos (std::ostream & os, const std::string & _svcName) const {
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[0].idName << " (\"" << msgSpecs[0].idName << "\");\n";
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[1].idName << " (\"" << msgSpecs[1].idName << "\");\n";
}

void SvcFuncP3V::printCPPDecCliSvcMemberFunc (std::ostream & os) const {
  os << "  void " << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it);\n";
}

void SvcFuncP3V::printCPPDefCliSvcMemberFunc (std::ostream & os, const std::string & classNam) const {
  os << "void " << classNam << "::" << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it){\n"
     << "  MDatReceiver<" << msgSpecs[1].mdat_p->getCPPName() << "> dat_it(_dat_it);\n"
     << "  " << msgSpecs[2].mdat_p->getCPPName() << " fin;\n"
     << "  funcP3VX (info_" << msgSpecs[0].idName << ".getVal(), _req,\n"
     << "            info_" << msgSpecs[1].idName << ".getVal(), dat_it, fin);\n"
     << "  if (fin.getStatus()) throw fin;\n"
     << "}\n";
}

void SvcFuncP3V::printJDefSvc (std::ostream &os) const {
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException;\n";
}

void SvcFuncP3V::printJDefSvcInt (std::ostream &os) const {
  os << "\tprivate " << msgSpecs[1].mdat_p->getJUserName() << "[] __" << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n"
     << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n"
     << "\t\tfinal int tok3=com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << ";\n"
     << "\t\tVector v = new Vector(20);\n"
     << '\n'
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
     << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
     << "\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r;\n"
     << "\t\twhile(true) {\n"
     << "\t\t\tbyte[] outBytes=cmRef.recvRecord();\n"
     << "\t\t\tif (cmRef.getToken()==tok3) {\n"
     << "\t\t\t\tr = new " << msgSpecs[2].mdat_p->getJUserName() << "(tok3,outBytes);\n"
     << "\t\t\t\tif (r." << msgSpecs[2].mdat_p->getCtlVar() << "!=0) throw (new bexException(r, r."
     << msgSpecs[2].mdat_p->getCtlVar() << "));\n"
     << "\t\t\t\tbreak;\n"
     << "\t\t\t\t}\n"
     << "\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " o = new " 
     << msgSpecs[1].mdat_p->getJUserName() << " (tok2,outBytes);\n"
     << "\t\t\tif ((c==null) || (!c.partial(o)) ) v.addElement(o);\n"
     << "\t\t}\n"
     << "\t\t" << msgSpecs[1].mdat_p->getJUserName() << " out[]=new " 
     << msgSpecs[1].mdat_p->getJUserName() << "[v.size()];\n"
     << "\t\tfor (int i=0;i<v.size();i++)\n"
     << "\t\t\tout[i]=(" << msgSpecs[1].mdat_p->getJUserName() << ")v.elementAt(i);\n"
     << "\t\treturn out;\n"
     << "\t}\n";
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t\telse { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t}\n";
}

void SvcFuncP3V::printJDefSvcImp (std::ostream &os) const {
  os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
     << "\t\t\t{\n"
     << "\t\t\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r=new " << msgSpecs[2].mdat_p->getJUserName() << "();\n"
     << "\t\t\t\ttry {\n"
     << "\t\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
     << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
     << ",inBytes);\n"
     << "\t\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << "[] a_out=_svcRef." << getMangledName() << "(a_in,null);\n"
     << "\t\t\t\t\tfor ( int i=0; i<a_out.length; i++)\n"
     << "\t\t\t\t\t\tcmRef.sendRecord(a_out[i].flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "=0;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcatch( bexException bEx ) {\n"
     << "\t\t\t\t\tif (" << msgSpecs[2].mdat_p->getJUserName() << ".class.isInstance(bEx.getCtlMDat())) r=(" 
     << msgSpecs[2].mdat_p->getJUserName() << ") bEx.getCtlMDat();\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "= (short) bEx.rCode;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << "));\n"
     << "\t\t\t\treturn true;\n"
     << "\t\t\t}\n";
}

void SvcFuncP3V::printJDefEnv (std::ostream &os, const std::vector<bool> & flagMatched,
			      const std::vector<std::vector<MsgSpec>::size_type> & idxMatched,
			      const std::vector<EnvArg> & envArgs) const {
  os << "\tpublic ";
  if (flagMatched[1]) os << "void ";
  else os << msgSpecs[1].mdat_p->getJUserName() << "[] ";
  os << getMangledName() << " (";
  if (!flagMatched[0]) os << msgSpecs[0].mdat_p->getJUserName() << " a_in,";
  os << "bexCallBack c) throws cmException, marshallingException, bexException {\n";
  if (flagMatched[1]) 
    {
      if (envArgs[idxMatched[1]].getVarName().empty())
	throw logic_error ("Root mdata is detected to be a vector in SvcFuncP3V::printJDefEnv.");
      else
	os << "\t\t" << envArgs[idxMatched[1]].getVarName() << " = ";
    }
  else os << "\t\treturn ";
  os << "_svcRef." << getMangledName() << "(";
  if (flagMatched[0])
    {
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
    }
  else os << "a_in";
  os << ",c);\n"
     << "\t}\n";
}

//
// SvcFuncP4N implementations
//

void SvcFuncP4N::printCPPDeclaration (std::ostream &os) const {
  os << "void " << getName() << "_ (const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it)";
}

void SvcFuncP4N::printCPPDecTokInfos (std::ostream & os) const {
  os << "  static TokInfo info_" << msgSpecs[0].idName << ";\n";
  os << "  static TokInfo info_" << msgSpecs[1].idName << ";\n";
}
void SvcFuncP4N::printCPPDefAddSvcFunc (std::ostream & os, const std::string & _svcName) const {
}

void SvcFuncP4N::printCPPDefTokInfos (std::ostream & os, const std::string & _svcName) const {
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[0].idName << " (\"" << msgSpecs[0].idName << "\");\n";
  os << "TokInfo " << _svcName << "::info_" << msgSpecs[1].idName << " (\"" << msgSpecs[1].idName << "\");\n";
}

void SvcFuncP4N::printCPPDecCliSvcMemberFunc (std::ostream & os) const {
  os << "  void " << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it);\n";
  os << "  void " << getName() << "_ ("
     << "const " << msgSpecs[3].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it);\n";
}

void SvcFuncP4N::printCPPDefCliSvcMemberFunc (std::ostream & os, const std::string & classNam) const {
  os << "void " << classNam << "::" << getName() << "_ ("
     << "const " << msgSpecs[0].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it){\n"
     << "  MDatReceiver<" << msgSpecs[1].mdat_p->getCPPName() << "> dat_it(_dat_it);\n"
     << "  " << msgSpecs[2].mdat_p->getCPPName() << " fin;\n"
     << "  funcP3VX (info_" << msgSpecs[0].idName << ".getVal(), _req,\n"
     << "            info_" << msgSpecs[1].idName << ".getVal(), dat_it, fin);\n"
     << "  if (fin.getStatus()) throw fin;\n"
     << "}\n";
  os << "void " << classNam << "::" << getName() << "_ ("
     << "const " << msgSpecs[3].mdat_p->getCPPName() << " & _req, "
     << "const Inserter<" << msgSpecs[1].mdat_p->getCPPName() << "> & _dat_it){\n"
     << "  MDatReceiver<" << msgSpecs[1].mdat_p->getCPPName() << "> dat_it(_dat_it);\n"
     << "  " << msgSpecs[2].mdat_p->getCPPName() << " fin;\n"
     << "  funcP3VX (_req.getTok(), _req,\n"
     << "            info_" << msgSpecs[1].idName << ".getVal(), dat_it, fin);\n"
     << "  if (fin.getStatus()) throw fin;\n"
     << "}\n";
}

void SvcFuncP4N::printJDefSvc (std::ostream &os) const {
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException;\n";

  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[3].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException;\n";
}

void SvcFuncP4N::printJDefSvcInt (std::ostream &os) const {
  os << "\tprivate " << msgSpecs[1].mdat_p->getJUserName() << "[] __" << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ";\n"
     << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n"
     << "\t\tfinal int tok3=com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << ";\n"
     << "\t\tVector v = new Vector(20);\n"
     << '\n'
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
     << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
     << "\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r;\n"
     << "\t\twhile(v.size() < a_in." << msgSpecs[1].vectorSizeName << ") {\n"
     << "\t\t\tbyte[] outBytes=cmRef.recvRecord();\n"
     << "\t\t\tif (cmRef.getToken()==tok3) {\n"
     << "\t\t\t\tr = new " << msgSpecs[2].mdat_p->getJUserName() << "(tok3,outBytes);\n"
     << "\t\t\t\tif (r." << msgSpecs[2].mdat_p->getCtlVar() << "!=0) throw (new bexException(r, r."
     << msgSpecs[2].mdat_p->getCtlVar() << "));\n"
     << "\t\t\t\tbreak;\n"
     << "\t\t\t\t}\n"
     << "\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " o = new " 
     << msgSpecs[1].mdat_p->getJUserName() << " (tok2,outBytes);\n"
     << "\t\t\tif ((c==null) || (!c.partial(o)) ) v.addElement(o);\n"
     << "\t\t}\n"
     << "\t\t" << msgSpecs[1].mdat_p->getJUserName() << " out[]=new " 
     << msgSpecs[1].mdat_p->getJUserName() << "[v.size()];\n"
     << "\t\tfor (int i=0;i<v.size();i++)\n"
     << "\t\t\tout[i]=(" << msgSpecs[1].mdat_p->getJUserName() << ")v.elementAt(i);\n"
     << "\t\treturn out;\n"
     << "\t}\n";
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[0].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t\telse { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t}\n";

  os << "\tprivate " << msgSpecs[1].mdat_p->getJUserName() << "[] __" << getMangledName()
     << " (" << msgSpecs[3].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tfinal int tok1=com.syncsort.bex.msg.keyword." << msgSpecs[3].keyword << ";\n"
     << "\t\tfinal int tok2=com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << ";\n"
     << "\t\tfinal int tok3=com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << ";\n"
     << "\t\tVector v = new Vector(20);\n"
     << '\n'
     << "\t\tif (a_in == null) {\n\t\t\t//throw new NullPointerException(\"" << getMangledName() << ": a null request mdata is given\");\n\t\t} else\n"
     << "\t\t\tcmRef.sendRecord(a_in.flatten(tok1));\n"
     << "\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r;\n"
     << "\t\twhile(v.size() < a_in." << msgSpecs[1].vectorSizeName << ") {\n"
     << "\t\t\tbyte[] outBytes=cmRef.recvRecord();\n"
     << "\t\t\tif (cmRef.getToken()==tok3) {\n"
     << "\t\t\t\tr = new " << msgSpecs[2].mdat_p->getJUserName() << "(tok3,outBytes);\n"
     << "\t\t\t\tif (r." << msgSpecs[2].mdat_p->getCtlVar() << "!=0) throw (new bexException(r, r."
     << msgSpecs[2].mdat_p->getCtlVar() << "));\n"
     << "\t\t\t\tbreak;\n"
     << "\t\t\t\t}\n"
     << "\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << " o = new " 
     << msgSpecs[1].mdat_p->getJUserName() << " (tok2,outBytes);\n"
     << "\t\t\tif ((c==null) || (!c.partial(o)) ) v.addElement(o);\n"
     << "\t\t}\n"
     << "\t\t" << msgSpecs[1].mdat_p->getJUserName() << " out[]=new " 
     << msgSpecs[1].mdat_p->getJUserName() << "[v.size()];\n"
     << "\t\tfor (int i=0;i<v.size();i++)\n"
     << "\t\t\tout[i]=(" << msgSpecs[1].mdat_p->getJUserName() << ")v.elementAt(i);\n"
     << "\t\treturn out;\n"
     << "\t}\n";
  os << "\tpublic " << msgSpecs[1].mdat_p->getJUserName() << "[] " << getMangledName()
     << " (" << msgSpecs[3].mdat_p->getJUserName() 
     << " a_in, bexCallBack c) throws cmException, marshallingException, bexException {\n"
     << "\t\tif (cmRef.isSyncIO()) synchronized (cmRef) { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t\telse { return __" << getMangledName() << " (a_in, c); }\n"
     << "\t}\n";
}

void SvcFuncP4N::printJDefSvcImp (std::ostream &os) const {
  os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword << ":\n"
     << "\t\t\t{\n"
     << "\t\t\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r=new " << msgSpecs[2].mdat_p->getJUserName() << "();\n"
     << "\t\t\t\ttry {\n"
     << "\t\t\t\t\t" << msgSpecs[0].mdat_p->getJUserName() << " a_in=new "
     << msgSpecs[0].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[0].keyword
     << ",inBytes);\n"
     << "\t\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << "[] a_out=_svcRef." << getMangledName() << "(a_in,null);\n"
     << "\t\t\t\t\tfor ( int i=0; i<a_out.length; i++)\n"
     << "\t\t\t\t\t\tcmRef.sendRecord(a_out[i].flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
     << "\t\t\t\t\tif (a_out.length == a_in." << msgSpecs[1].vectorSizeName << ") return true;\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "=0;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcatch( bexException bEx ) {\n"
     << "\t\t\t\t\tif (" << msgSpecs[2].mdat_p->getJUserName() << ".class.isInstance(bEx.getCtlMDat())) r=(" 
     << msgSpecs[2].mdat_p->getJUserName() << ") bEx.getCtlMDat();\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "= (short) bEx.rCode;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << "));\n"
     << "\t\t\t\treturn true;\n"
     << "\t\t\t}\n";

  os << "\t\t\tcase com.syncsort.bex.msg.keyword." << msgSpecs[3].keyword << ":\n"
     << "\t\t\t{\n"
     << "\t\t\t\t" << msgSpecs[2].mdat_p->getJUserName() << " r=new " << msgSpecs[2].mdat_p->getJUserName() << "();\n"
     << "\t\t\t\ttry {\n"
     << "\t\t\t\t\t" << msgSpecs[3].mdat_p->getJUserName() << " a_in=new "
     << msgSpecs[3].mdat_p->getJUserName() << "(com.syncsort.bex.msg.keyword." << msgSpecs[3].keyword
     << ",inBytes);\n"
     << "\t\t\t\t\t" << msgSpecs[1].mdat_p->getJUserName() << "[] a_out=_svcRef." << getMangledName() << "(a_in,null);\n"
     << "\t\t\t\t\tfor ( int i=0; i<a_out.length; i++)\n"
     << "\t\t\t\t\t\tcmRef.sendRecord(a_out[i].flatten(com.syncsort.bex.msg.keyword." << msgSpecs[1].keyword << "));\n"
     << "\t\t\t\t\tif (a_out.length == a_in." << msgSpecs[1].vectorSizeName << ") return true;\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "=0;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcatch( bexException bEx ) {\n"
     << "\t\t\t\t\tif (" << msgSpecs[2].mdat_p->getJUserName() << ".class.isInstance(bEx.getCtlMDat())) r=(" 
     << msgSpecs[2].mdat_p->getJUserName() << ") bEx.getCtlMDat();\n"
     << "\t\t\t\t\tr." << msgSpecs[2].mdat_p->getCtlVar() << "= (short) bEx.rCode;\n"
     << "\t\t\t\t\t}\n"
     << "\t\t\t\tcmRef.sendRecord(r.flatten(com.syncsort.bex.msg.keyword." << msgSpecs[2].keyword << "));\n"
     << "\t\t\t\treturn true;\n"
     << "\t\t\t}\n";
}

void SvcFuncP4N::printJDefEnv (std::ostream &os, const std::vector<bool> & flagMatched,
			      const std::vector<std::vector<MsgSpec>::size_type> & idxMatched,
			      const std::vector<EnvArg> & envArgs) const {
  os << "\tpublic ";
  if (flagMatched[1]) os << "void ";
  else os << msgSpecs[1].mdat_p->getJUserName() << "[] ";
  os << getMangledName() << " (";
  if (!flagMatched[0]) os << msgSpecs[0].mdat_p->getJUserName() << " a_in,";
  os << "bexCallBack c) throws cmException, marshallingException, bexException {\n";
  if (flagMatched[1]) 
    {
      if (envArgs[idxMatched[1]].getVarName().empty())
	throw logic_error ("Root mdata is detected to be a vector in SvcFuncP4N::printJDefEnv.");
      else
	os << "\t\t" << envArgs[idxMatched[1]].getVarName() << " = ";
    }
  else os << "\t\treturn ";
  os << "_svcRef." << getMangledName() << "(";
  if (flagMatched[0])
    {
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
    }
  else os << "a_in";
  os << ",c);\n"
     << "\t}\n";

  os << "\tpublic ";
  if (flagMatched[1]) os << "void ";
  else os << msgSpecs[1].mdat_p->getJUserName() << "[] ";
  os << getMangledName() << " (";
  if (!flagMatched[3]) os << msgSpecs[3].mdat_p->getJUserName() << " a_in,";
  os << "bexCallBack c) throws cmException, marshallingException, bexException {\n";
  if (flagMatched[1]) 
    {
      if (envArgs[idxMatched[1]].getVarName().empty())
	throw logic_error ("Root mdata is detected to be a vector in SvcFuncP4N::printJDefEnv.");
      else
	os << "\t\t" << envArgs[idxMatched[1]].getVarName() << " = ";
    }
  else os << "\t\treturn ";
  os << "_svcRef." << getMangledName() << "(";
  if (flagMatched[0])
    {
      if (envArgs[idxMatched[0]].getVarName().empty())
	os << "this";
      else
	os << envArgs[idxMatched[0]].getVarName();
    }
  else os << "a_in";
  os << ",c);\n"
     << "\t}\n";
}

//
// SvcFunc implementations
//

void SvcFunc::printCDecMsg (std::ostream &os) const {
  for (std::vector<MsgSpec>::size_type i=0; i<msgSpecs.size(); i++)
    msgSpecs[i].printCDecMsg(os);
}

void SvcFunc::printCDefMsg (std::ostream &os) const {
  for (std::vector<MsgSpec>::size_type i=0; i<msgSpecs.size(); i++)
    msgSpecs[i].printCDefMsg(os);
}

void SvcFunc::printCPPJComments (std::ostream &os) const {
  // paste in the comments associated with this function 
  if (comments.size())
    for (std::vector<std::string>::size_type i=0; i<comments.size(); i++)
      os << "\t\t//" << comments[i] << '\n';
}


//
// SvcDef implementations
//
SvcDef::SvcDef(const std::string & _name, const std::string & _serverName, const SvcMembers & _members) : 
  Base (_name), 
  serverName (_serverName), 
  methods (_members.methods),
  envs(_members.envs)
{ 
  setMangledNames ();
  store.insert(_name,Ptr(this));
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->setMsgIDs (getName());
  for (std::vector<EnvTypeInfo::Ptr>::size_type i=0; i<envs.size(); i++)
    envs[i]->setSvc (Ptr(this));
}

void SvcDef::setCPPName () { 
  Base::setCPPName("MDatSvc_" + getName()); 
  cppCliSvcNam = "MDatClientSvc_" + getName();
}

void SvcDef::setJName () { 
  Base::setJName("Svc_" + getName()); 
  jSvcName = "SvcInt_" + getName();
  jSvcImpName = "SvcProvider_" + getName();
}

void SvcDef::printCDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C Declaration for service " + getName());
  os << '\n';

  // the message generation functions needed for each function (msg_create/parse_X's)
  printCDecMsg (os);
  os << '\n';
}

void SvcDef::printCDecMsg (std::ostream & os) const {
  // the message generation functions needed for each function (msg_create/parse_X's)
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCDecMsg(os);

  // Inclusion (H)
  if (incInfo.hasInclusion(InclusionInfo::INC_H)) {
    os << '\n';
    incInfo.printInclusion (os, InclusionInfo::INC_H);
  }
}

void SvcDef::printCPPDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C++ Declaration for service " + getName());
  os << '\n';

  // C++ specific declarations
  {
    os << "namespace gen {\n";
    os << '\n';
    
    // the MDatSvc_ class definition
    printCPPDecSvc (os);
    os << '\n';
    
    // the MDatClientSvc_ class definition
    printCPPDecCliSvc (os);
    os << '\n';
    
    // the related envelope class definitions
//    printCPPDecEnvs (os);
//    os << '\n';

    // Inclusion (HPP)
    if (incInfo.hasInclusion(InclusionInfo::INC_HPP)) {
      incInfo.printInclusion (os, InclusionInfo::INC_HPP);
      os << '\n';
    }
    
    os << "} // namespace gen\n";
  }
}

void SvcDef::printCPPDecSvc (std::ostream & os) const {
  os << "// -- service interface abstract base class --\n"
     << "class " << getCPPName() << " : public MDatSvc {\n"
     << "public:\n";
  // declare the TokInfo's
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++) {
    methods[i]->printCPPDecTokInfos (os);
  }
  // declare the constructor
  os << "  " << getCPPName() << "();\n";
  // declare the destructor virtual
  os << "  virtual ~" << getCPPName() << " () {}\n"
     << "\n";
  
  // member functions are declared as pure virtual in this abstract class
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      os << "  virtual ";
      methods[i]->printCPPDeclaration (os);
      os << " =0;\n";
      methods[i]->printCPPJComments (os);
    }
  os << "};\n";
}

void SvcDef::printCPPDecCliSvc (std::ostream & os) const {
  os << "class " << cppCliSvcNam << " : public MDatClientSvc, public " << getCPPName() << " {\n";
  os << "public:\n";

  // constructor
  os << "  " <<  cppCliSvcNam << "(MDatStream & _server);\n";
  // member functions declared (X_)
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCPPDecCliSvcMemberFunc (os);

  os << "};\n";

}

void SvcDef::printCPPDecEnvs (std::ostream & os) const {
  for (std::vector<EnvTypeInfo::Ptr>::size_type i=0; i<envs.size(); i++)
    if (envs[i]->isFullyDefined())
      {
	if (i>0) os << '\n';
	envs[i]->printCPPDeclaration (os);
      }
}

void SvcDef::printCDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C Definition for service " + getName());
  os << '\n';

  // print out the message generation functions needed for each function
  printCDefMsg (os);
  os << '\n';
}

void SvcDef::printCDefMsg (std::ostream & os) const {
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCDefMsg(os);
}

void SvcDef::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for service " + getName());
  os << '\n';

  // C++ specific definitions
  {
    os << "namespace gen {\n";
    os << '\n';
    
    // the MDatSvc_ class definition
    printCPPDefSvc (os);
    os << '\n';
    
    // the MDatClientSvc_ class definition
    printCPPDefCliSvc (os);
    os << '\n';
    
    // the related envelope class definitions
//    printCPPDefEnvs (os);
//    os << '\n';

    // Inclusion (CPP)
    if (incInfo.hasInclusion(InclusionInfo::INC_CPP)) {
      incInfo.printInclusion (os, InclusionInfo::INC_CPP);
      os << '\n';
    }
    
    os << "} // namespace gen\n";
  }
}

void SvcDef::printCPPDefSvc (std::ostream & os) const {
  // define the TokInfo's
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCPPDefTokInfos (os, getCPPName());
  // constructor
  os << getCPPName() << "::" << getCPPName() << "() : MDatSvc(\"" << getName() << "\") {\n";
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCPPDefAddSvcFunc (os, getCPPName());
  os << "}\n";
}

void SvcDef::printCPPDefCliSvc (std::ostream & os) const {
  // constructor
  os << cppCliSvcNam << "::" <<  cppCliSvcNam << "(MDatStream & _server) : MDatClientSvc (_server)";
  os << " {};\n";
  // member functions defined (X_)
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    methods[i]->printCPPDefCliSvcMemberFunc (os, cppCliSvcNam);
}

void SvcDef::printCPPDefEnvs (std::ostream & os) const {
  for (std::vector<EnvTypeInfo::Ptr>::size_type i=0; i<envs.size(); i++)
    if (envs[i]->isFullyDefined())
      {
	if (i>0) os << '\n';
	envs[i]->printCPPDefinition (os);
      }
}

void SvcDef::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  // print out the service client class definition
  printJDefSvc (javaDir, inFileName);

  // print out the service interface class definition
  printJDefSvcInt (javaDir, inFileName);

  // print out the service provider class definition
  printJDefSvcImp (javaDir, inFileName);

  // print out the associated envelope class definitions, if fully defined.
  printJDefEnvs (javaDir, inFileName);
}

void SvcDef::printJDefSvc (const std::string & javaDir, const std::string & inFileName) const {
  NativeJFile jFile (getJSvcName(), javaDir);
  msgc_glob.javafiles.push_back (getJSvcName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os) 
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n"
     << "import com.syncsort.bex.cm.*;\n"
     << "import java.util.*;\n"
     << '\n';

  codeDelim _cd(os, "Java Definition for service interface class based on service " + getName());
  os << '\n';

  os << "public interface " << getJSvcName() << " {\n";

  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  // member functions 
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      methods[i]->printJDefSvc (os);
      methods[i]->printCPPJComments (os);
      os << '\n';
    }

  // Inclusion (JAVA)
  if (incInfo.hasInclusion(InclusionInfo::INC_JAVA)) {
    incInfo.printInclusion (os, InclusionInfo::INC_JAVA);
    os << '\n';
  }

  os << "}\n";
  os << '\n';
}
void SvcDef::printJDefSvcInt (const std::string & javaDir, const std::string & inFileName) const {
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os) 
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n"
     << "import com.syncsort.bex.cm.*;\n"
     << "import java.util.*;\n"
     << '\n';

  codeDelim _cd(os, "Java Definition for service interface class based on service " + getName());
  os << '\n';

  os << "public class " << getJName() << " extends svcBase implements " << getJSvcName() << " {\n";

  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  // constructor
  os << "\tpublic " << getJName() << " (cmClient c) {\n"
     << "\t\tcmRef=c;\n";
//  for (std::vector<EnvTypeInfo::Ptr>::size_type i=0; i<envs.size(); i++)
//    os << "\t\t" << envs[i]->getJName() << "._svcRef=this;\n";
  os << "\t}\n";
  os << '\n';

  // member functions 
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      methods[i]->printJDefSvcInt (os);
      methods[i]->printCPPJComments (os);
      os << '\n';
    }

  // Inclusion (JAVA)
  if (incInfo.hasInclusion(InclusionInfo::INC_JAVA)) {
    incInfo.printInclusion (os, InclusionInfo::INC_JAVA);
    os << '\n';
  }

  os << "}\n";
  os << '\n';
}

void SvcDef::printJDefSvcImp (const std::string & javaDir, const std::string & inFileName) const {
  NativeJFile jFile (getJSvcImpName(), javaDir);
  msgc_glob.javafiles.push_back (getJSvcImpName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os) 
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n"
     << "import com.syncsort.bex.cm.*;\n"
     << "import java.lang.reflect.*;\n"
     << "import java.util.*;\n"
     << '\n';

  codeDelim _cd(os, "Java Definition for service implementation class based on service " + getName());
  os << '\n';

  os << "public class " << getJSvcImpName() << " extends svcHandlerBase {\n"
     << "\t" << getJSvcName() << " _svcRef;\n"
     << '\n';
    
  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  // constructor
  os << "\tpublic " << getJSvcImpName() << " (" << getJSvcName() << " b) {\n"
     << "\t\t_svcRef=b;\n"
     << "\t\ttoks = new Vector(toksAll);\n"
     << "\t\tif (b instanceof com.syncsort.bex.msg.svcIsIncomplete) {\n"
     << "\t\t\tMethod[] unimps = ((svcIsIncomplete) b).listUnimplemented();\n"
     << "\t\t\tfor (int i=0; i<unimps.length; i++)\n"
     << "\t\t\ttoks.removeElement (funcMap.get (unimps[i].getName()));\n"
     << "\t\t}\n"
     << "\t}\n"
     << '\n'

  // listToks() function
     << "\tpublic Vector listToks () { return toks; }\n"
     << "\tpublic static Vector toks = new Vector();\n"
     << "\tpublic static Vector toksAll = new Vector();\n"
     << "\tstatic {\n";
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      os << "\t\ttoksAll.addElement(new Short(com.syncsort.bex.msg.keyword." << methods[i]->msgSpecs[0].keyword << "));\n";
    }
  os << "\t}\n\n"

  // funcMap () hash array
     << "\tpublic static HashMap funcMap = new HashMap();\n"
     << "\tstatic {\n";
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      os << "\t\tfuncMap.put(\"" << methods[i]->getMangledName() 
	<< "\", new Short(com.syncsort.bex.msg.keyword." << methods[i]->msgSpecs[0].keyword << ") );\n";
    }
  os << "\t}\n\n"

  // process() function
     << "\tpublic final boolean process (short token, cmServer cmRef, byte[] inBytes)\n"
     << "\t\t\t\t\tthrows cmException, marshallingException {\n"
     << "\t\tswitch (token) {\n";

  // various "case" statements, each corresponding to a function.
  for (std::vector<SvcFunc *>::size_type i=0; i<methods.size(); i++)
    {
      methods[i]->printJDefSvcImp (os);
      os << '\n';
    }

  // Inclusion (JAVA)
  if (incInfo.hasInclusion(InclusionInfo::INC_JAVA)) {
    incInfo.printInclusion (os, InclusionInfo::INC_JAVA);
    os << '\n';
  }

  os << "\t\t\tdefault:\n"
     << "\t\t\t\t return false;\n"
     << '\n'
     << "\t\t\t}\n" // end of switch
     << "\t}\n" // end of process()
     << "}\n" // end of class def
     << '\n';
}

void SvcDef::printJDefEnvs (const std::string & javaDir, const std::string & inFileName) const {
  for (std::vector<EnvTypeInfo::Ptr>::size_type i=0; i<envs.size(); i++)
    if (envs[i]->isFullyDefined())
      envs[i]->printJDefinition (javaDir, inFileName);
}

//
// EnvTypeInfo implementations
//

EnvTypeInfo::EnvTypeInfo (const std::string & _name, const std::vector<EnvMethodDef> _methods) : 
  Base (_name), svc_p(0)
{ 
  setMangledNames(); 
  setMethods (_methods);
  store.insert(_name,Ptr(this)); 
}

void EnvTypeInfo::setSvc (SvcDef::Ptr _svc_p) {
  svc_p = _svc_p;
}

void EnvTypeInfo::setMethods (const std::vector <EnvMethodDef> _methods) {
  methods = _methods;
  // find "root mdata", if any, set up mdats and args.
  int count = 0;
  for (std::vector<EnvMethodDef>::size_type i=0; i<methods.size(); i++)
    for (std::vector<EnvArg>::size_type j=0; j<methods[i].args.size(); j++)
      if (methods[i].args[j].varName.empty()) 
	{
	  if (++count>1) 
	    {
	      if (rootMDat_p->getName() != methods[i].args[j].mdat_p->getName())
		throw msgc_exception("Only one root mdata can be declared in an envelope.  ("+getName()+")");
	    }
	  else 
	    rootMDat_p = methods[i].args[j].mdat_p;
	}
      else
	{
	  // mdats is the list of mdata which are hidden
	  std::vector<MDataTypeInfo::Ptr>::size_type k;
	  for (k=0; k<mdats.size(); k++)
	    if (mdats[k]->getName() == methods[i].args[j].mdat_p->getName()) break;
	  if (k==mdats.size()) mdats.push_back (methods[i].args[j].mdat_p);
	  // EnvTypeInfo::args is the list of variables to be members of the envelope
	  std::vector<EnvArg>::size_type l;
	  for (l=0; l<args.size(); l++)
	    if (args[l].varName == methods[i].args[j].varName) break;
	  if (l==args.size()) args.push_back (methods[i].args[j]);
	}
}

std::vector<EnvMethodDef>::size_type 
EnvTypeInfo::findMatchMethodDef (const std::vector<MsgSpec> & svcArgs, const std::string & svcName,
				 std::vector<bool> & flagMatched,
				 std::vector<std::vector<MsgSpec>::size_type> & idxMatched) const {
  std::vector<EnvMethodDef>::size_type k;
  for (k=0; k<methods.size(); k++)
    if ((methods[k].getName()=="*") || (methods[k].getName()==svcName)) // name matches
      {
	for (std::vector<bool>::size_type m=0; m<flagMatched.size(); m++) flagMatched[m]=false;
	const std::vector<EnvArg> & envArgs = methods[k].args; // just a short name
	// we'll loop over the envelope method desc's arguments first.
	// all of these must match an argument in the service method's arg list
	// for us to consider that the methods "match."
	std::vector<EnvArg>::size_type l;
	for (l=0; l<envArgs.size(); l++)
	  {
	    std::vector<MsgSpec>::size_type m;
	    for (m=0; m<svcArgs.size(); m++)
	      if (!flagMatched[m]	// each svcArg can only match once
		  && (svcArgs[m].mdat_p->getName() == envArgs[l].mdat_p->getName())
		  && (svcArgs[m].isVector() == envArgs[l].isVector()) ) break;
	    if (m<svcArgs.size())
	      {
		flagMatched[m] = true;
		idxMatched[m] = l;
	      }
	    else
	      break;  // l'th envArg did not match
	  }
	if (l==envArgs.size())  // all of envArgs matched.  we have a match!
	  break;
      }
  return k;
}

void EnvTypeInfo::printCDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C Declaration for envelope " + getName());
  os << '\n';
}

void EnvTypeInfo::printCPPDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C++ Declaration for envelope " + getName());
  os << '\n';
  
  os << "#ifdef __cplusplus\n";
  os << '\n';

  // it's a template if 1 or more (non-root) mdat_args
  if (mdats.size())
    {
      os << "template <";
      bool flag_comma = false;
      for (std::vector<MDataTypeInfo::Ptr>::size_type i=0; i< mdats.size(); i++)
	{
	  if (flag_comma) os << ", ";
	  else flag_comma = true;
	  os << "class " << "TP_"+mdats[i]->getName() << " =" << mdats[i]->getCPPName();
	}
      os << " >\n";
    }

  // start the class definition
  os << "class " << getCPPName()+(mdats.size()?"_":"");

  // if there's a root_mdat, then this inherits from that mdata class 
  if (hasRootMData())
    os << ": public " << rootMDat_p->getCPPName();
  os << " {\n"
  // private data - ref to svc
     << "  " << svc_p->getCPPName() << " & _svcRef;\n";

  // public data - args
  if (args.size()>0)
    {
      os << "public:\n";
      for (std::vector<EnvArg>::size_type i=0; i<args.size(); i++)
	os << "  " << "TP_"+args[i].mdat_p->getName() << " " << args[i].varName << ";\n";
      os << '\n';
    }

  // constructor
  os << "public:\n"
     << "  " << getCPPName()+(mdats.size()?"_":"") << " (" 
     << svc_p->getCPPName() << " & __svcRef) : _svcRef(__svcRef) {}\n"
     << '\n';

  // export the methods
  const std::vector<SvcFunc *> & svcMethods = svc_p->methods;
  for (std::vector<SvcFunc *>::size_type j=0; j<svcMethods.size(); j++)
    {
      // look for the first envelope method description that matches this function
      std::vector<bool> flagMatched (svcMethods[j]->msgSpecs.size(), false);
      std::vector<std::vector<MsgSpec>::size_type> idxMatched (svcMethods[j]->msgSpecs.size(), 0);
      std::vector<EnvMethodDef>::size_type k = 
	findMatchMethodDef (svcMethods[j]->msgSpecs, svcMethods[j]->getName(), flagMatched, idxMatched);
      if (k<methods.size())  // found a matching method descriptor, now print
	{ 
	  os << "  void " << svcMethods[j]->getMangledName() << " (";
	  {
	    const std::vector<MsgSpec> & svcArgs = svcMethods[j]->msgSpecs;
	    bool flagComma = false;
	    for (std::vector<MsgSpec>::size_type l=0; l<svcArgs.size(); l++)
	      {
		if (flagMatched[l]) continue; // this argument was hidden
		if (flagComma) os << ", "; 
		else flagComma = true;
		os << svcArgs[l].mdat_p->getCPPName() << " & arg_" << l;
	      }
	  }
	  os << ") { _svcRef." << svcMethods[j]->getMangledName() << " (";
	  {
	    const std::vector<EnvArg> & envArgs = methods[k].args;
	    const std::vector<MsgSpec> & svcArgs = svcMethods[j]->msgSpecs;
	    for (std::vector<MsgSpec>::size_type l=0; l<svcArgs.size(); l++)
	      {
		if (l!=0) os << ", "; 
		if (flagMatched[l]) // this argument was hidden
		  {
		    if (envArgs[idxMatched[l]].varName.empty())
		      os << "*this";
		    else
		      os << envArgs[idxMatched[l]].varName;
		  }
		else
		  os << "arg_" << l;
	      }
	  }
	  os << "); }\n";
	}
    }
  os << "};\n";

  // use typedef if the envelope was a template
  if (mdats.size())
    os << "typedef " << getCPPName()+"_" << "<> " << getCPPName() << ";\n";

  os << '\n';
  os << "#endif /* ifdef __cplusplus */\n";
}

void EnvTypeInfo::printCDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C Definition for envelope " + getName());
}

void EnvTypeInfo::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for envelope " + getName());
}

void EnvTypeInfo::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os)
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");

  // print informational
  os << "/****************************************************************\n"
     << "* AUTOGENERATED FILE (" << jFile.getFileName() << ") from (" << inFileName << ")\n"
     << "*  -- DO NOT EDIT --\n"
     << "****************************************************************/\n"
     << "package com.syncsort.bex.msg;\n"
     << "import com.syncsort.bex.cm.*;\n"
     << "import java.util.*;\n"
     << '\n';

  codeDelim _cd(os, "Java Definition for envelope " + getName());

  // start the class definition
  os << "public class " << getJName();

  // if there's a root_mdat, then this inherits from that mdata class 
  if (hasRootMData())
    os << " extends " << rootMDat_p->getJName();
  os << " {\n";
  // version string
  if (msgc_glob.inFileVerStr != "")
    os << "  public static final String _verstr =" << msgc_glob.inFileVerStr << ";\n";

  // private data - ref to svc
  os << "\tprotected " << svc_p->getJName() << " _svcRef;\n"
     << '\n';
  // class name string
  os << "\tprivate static final String _name=\"" << getJName() << "\";\n"
     << '\n';

  // public data - args
  if (args.size()>0)
    {
      for (std::vector<EnvArg>::size_type i=0; i<args.size(); i++)
	{
          os << "\tprivate " << args[i].mdat_p->getJName() << " " << args[i].varName << ";\n";
	  args[i].mdat_p->printJMemberIntDef (os, args[i].varName);
	}
      os << '\n';
    }

  // constructors
  os << "\tpublic " << getJName() << " () {\n";
  if (hasRootMData())
    os << "\t\tsuper ();\n";
  os << "\t}\n";
  os << '\n';

  os << "\tpublic " << getJName() << " (" << svc_p->getJName() << " s) {\n";
  if (hasRootMData())
    os << "\t\tsuper ();\n";
  os << "\t\t_svcRef=s;\n";
  os << "\t}\n";
  os << '\n';

  if (hasRootMData())
    {
      os << "\tpublic " << getJName() << " (int tok, byte[] bs) throws marshallingException {\n"
	 << "\t\tsuper (tok, bs);\n"
	 << "\t}\n";
      os << '\n';
    }

  // export the methods
  const std::vector<SvcFunc *> & svcMethods = svc_p->methods;
  for (std::vector<SvcFunc *>::size_type j=0; j<svcMethods.size(); j++)
    {
      // look for the first envelope method description that matches this function
      std::vector<bool> flagMatched (svcMethods[j]->msgSpecs.size(), false);
      std::vector<std::vector<MsgSpec>::size_type> idxMatched (svcMethods[j]->msgSpecs.size(), 0);
      std::vector<EnvMethodDef>::size_type k = 
	findMatchMethodDef (svcMethods[j]->msgSpecs, svcMethods[j]->getName(), flagMatched, idxMatched);
      if (k<methods.size())  // found a matching method descriptor, now print
	{
	  os << '\n';
	  svcMethods[j]->printJDefEnv (os, flagMatched, idxMatched, methods[k].args);
	}
    }

  os << "}" << '\n';
}

//
// SvrDef implementations
//

SvrDef::SvrDef (const std::string & _name, const std::string & _modID, const std::vector<SvrSvcSpec> _svcs) :
  Base (_name), 
  modID (_modID), 
  svcs (_svcs)
{ 
  setMangledNames ();
  store.insert(_name,Ptr(this)); 
}

void SvrDef::setCPPName () {
  Base::setCPPName("Svr_" + getName()); 
}

void SvrDef::setJName () {
  Base::setJName("Svr_" + getName()); 
}

void SvrDef::printCDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C Declaration for server " + getName());
}

void SvrDef::printCPPDeclaration (std::ostream & os) const {
  codeDelim _cd(os, "C++ Declaration for server " + getName());
}

void SvrDef::printCDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C Definition for server " + getName());
}

void SvrDef::printCPPDefinition (std::ostream & os) const {
  codeDelim _cd(os, "C++ Definition for server " + getName());
}

void SvrDef::printJDefinition (const std::string & javaDir, const std::string & inFileName) const {
  if (javaDir.empty()) return;
  NativeJFile jFile (getJName(), javaDir);
  msgc_glob.javafiles.push_back (getJName() + ".java");
  ofstream os (jFile.getFullName().c_str());
  if (!os)
    throw msgc_exception("Failed to open file "+jFile.getFullName()+" for output.");
}

//
// msgc main()
//
int
main (int argc, char * argv[])
{

/*
  - from msg_create_generic description:

    %c - TOK_TYPE_CHAR           char_sy *
    %d - TOK_TYPE_DOUBLE         double_sy *
    %i - TOK_TYPE_SHORT          short_sy *
    %k - TOK_TYPE_KEYWORD        keyword_sy *
    %l - TOK_TYPE_LONG           long_sy *
    %p - TOK_TYPE_ADDRESS        char_sy **
    %S - TOK_TYPE_STRING         char_sy **, short_sy *
    %s - TOK_TYPE_STRING         char_sy **, short_sy *
    %v - TOK_TYPE_VLONG          vlong_sy *
 
    %A - ** Array specifier **
    %C - TOK_TYPE_LONG           CHUNKID *
    %F - TOK_TYPE_LONG           FILEXID *
    %G - TOK_TYPE_SHORT          FSTYPE *
    %J - TOK_TYPE_LONG           JOBID *
    %N - TOK_TYPE_SHORT          NODETYPE *
    %P - TOK_TYPE_SHORT          PARTITION *
    %R - TOK_TYPE_SHORT          REQID *
    %T - TOK_TYPE_LONG           TASKID *
    %X - ** User function **
*/

  // primitive data types - just calling the constructor puts an instance into global store
  PrimTypeInfo::getNew ("char_sy", "char_sy", "char_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew (TCharSy::NAME, "char_sy", "char_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew (BCharSy::NAME, "char_sy", "char_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew (CCharSy::NAME, "char_sy", "char_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew (RCharSy::NAME, "char_sy", "char_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew ("uchar_sy", "uchar_sy", "uchar_sy", 'c', "TOK_putchar", "TOK_getchar", "byte", "B");
  PrimTypeInfo::getNew ("double_sy", "double_sy", "double_sy", 'd', "TOK_putdouble", "TOK_getdouble", "double", "D");
  PrimTypeInfo::getNew ("rcode_sy", "rcode_sy", "rcode_sy", 'i', "TOK_putshort", "TOK_getshort", "short", "S");
  PrimTypeInfo::getNew ("short_sy", "short_sy", "short_sy", 'i', "TOK_putshort", "TOK_getshort", "short", "S");
  PrimTypeInfo::getNew ("ushort_sy", "ushort_sy", "ushort_sy", 'i', "TOK_putshort", "TOK_getshort", "short", "S");
  PrimTypeInfo::getNew ("keyword_sy", "keyword_sy", "Keyword", 'k', "TOK_putkeyword", "TOK_getkeyword", "short", "K");
  PrimTypeInfo::getNew ("long_sy", "long_sy", "long_sy", 'l', "TOK_putlong", "TOK_getlong", "int", "I");
  PrimTypeInfo::getNew ("ulong_sy", "ulong_sy", "ulong_sy", 'l', "TOK_putlong", "TOK_getlong", "int", "I");
  PrimTypeInfo::getNew ("vlong_sy", "vlong_sy", "vlong_sy", 'v', "TOK_putvlong", "TOK_getvlong", "long", "J");
  PrimTypeInfo::getNew ("CHUNKID", "CHUNKID", "CHUNKID", 'C', "TOK_putchunkid", "TOK_getchunkid", "int", "I");
  PrimTypeInfo::getNew ("FILEXID", "FILEXID", "FILEXID", 'F', "TOK_putfilexid", "TOK_getfilexid", "int", "I");
  PrimTypeInfo::getNew ("FSTYPE", "FSTYPE", "FSTYPE", 'G', "TOK_putfstype", "TOK_getfstype", "short", "S");
  PrimTypeInfo::getNew ("JOBID", "JOBID", "JOBID", 'J', "TOK_putjobid", "TOK_getjobid", "int", "I");
  PrimTypeInfo::getNew ("NODETYPE", "NODETYPE", "NODETYPE", 'N', "TOK_putnodetype", "TOK_getnodetype", "short", "S");
  PrimTypeInfo::getNew ("PARTITION", "PARTITION", "PARTITION", 'P', "TOK_putpartition", "TOK_getpartition", "short", "S");
  PrimTypeInfo::getNew ("REQID", "REQID", "REQID", 'R', "TOK_putreqid", "TOK_getreqid", "short", "S");
  PrimTypeInfo::getNew ("TASKID", "TASKID", "TASKID", 'T', "TOK_puttaskid", "TOK_gettaskid", "int", "I");
  PrimTypeInfo::getNew ("time_t", "time_t", "time_t", 'l', "TOK_putlong", "TOK_getlong", "int", "I");
  PrimTypeInfo::getNew ("TIME_X", "TIME_X", "TIME_X", 'l', "TOK_putlong", "TOK_gettime", "int", "I");

  // parse the command line
  gen::CmdLine cl(argc,argv);
  std::string usage_str = 
    "Usage: msgc [-h]\n"
    "            [-d debug_level]\n"
    "            [-c c_output_dir]\n"
    "            [-cxx c++_output_dir]\n"
    "            [-j java_msgclass_dir]\n"
    "            [-I include_dir] message_file...";

  std::string optArg;
  while (cl.extractOpt("-c", msgc_glob.cOutDir));
  while (cl.extractOpt("-cxx", msgc_glob.cxxOutDir));
  while (cl.extractOpt("-j", msgc_glob.jOutDir));
  while (cl.extractOpt("-d", optArg)) std::istrstream(optArg.c_str()) >> msgc_glob.debug_level;
  while (cl.extractOpt("-I", optArg)) msgc_glob.incDirs.push_back(optArg);
  if (cl.extractOpt("-h")) {
    std::cerr << usage_str << endl;
    exit (0);
  }
  std::vector<std::string> badOpts = cl.extractOpts();
  std::vector<std::string> args = cl.getArgs();
  if (badOpts.size() || !args.size()) {
    std::cerr << usage_str << endl;
    exit (2);
  }
  // the set (inputfiles) orders the input Files so that *.m < *.s < *.svr
  // any duplicates would be eliminated by this as well (since set, not multiset, is used.)
  std::set<NativeInputFile> inputFiles (args.begin(), args.end());
  
  switch (msgc_glob.debug_level) 
    {
    default:
    case (3) :
      yydebug = msgc_glob.debug_level;
      msgc_glob.lexer.set_debug (msgc_glob.debug_level);
      break;
    case (2):
      yydebug = msgc_glob.debug_level;
      break;
    case (1):
      msgc_glob.lexer.set_debug (msgc_glob.debug_level);
      break;
    }

  for (std::set<NativeInputFile>::iterator inputFile=inputFiles.begin(); 
       inputFile != inputFiles.end(); ++inputFile)
    try {
    {
      // clear stores
      FlagTypeInfo::eraseAll();
      MDataTypeInfo::eraseAll();
      EnvTypeInfo::eraseAll();
      SvcDef::eraseAll();
      SvrDef::eraseAll();

      msgc_glob.mdatafile_set.clear();
      msgc_glob.svcfile_set.clear();
    }

    msgc_glob.inFileName = inputFile->getFileName ();
    msgc_glob.inFileFullName = inputFile->getFullName ();
    msgc_glob.inFileGuardNameBase = "_"+inputFile->getBase()+"_"+inputFile->getExtension();
    msgc_glob.inFileVerStr = "";
    
    // open up the input file for read
    if (msgc_glob.mdatafile_set.find (inputFile->getFileName()) != msgc_glob.mdatafile_set.end()) 
      throw msgc_exception ("mdata file ("+inputFile->getFileName()+
			    ") specified in the argument list has already been processed "+
			    "(possibly as an imported file)");
    if (msgc_glob.svcfile_set.find (inputFile->getFileName()) != msgc_glob.svcfile_set.end()) 
      throw msgc_exception ("svc file ("+inputFile->getFileName()+
			    ") specified in the argument list has already been processed "+
			    "(possibly as an imported file)");
    if (inputFile->getExtension()=="m") 
      msgc_glob.mdatafile_set.insert (inputFile->getFileName());
    if (inputFile->getExtension()=="s") 
      msgc_glob.svcfile_set.insert (inputFile->getFileName());
    ifstream isInFile (inputFile->getFullName().c_str());
    if (!isInFile)
      throw msgc_exception("Could not open file "+inputFile->getFullName()+" for read.");
    msgc_glob.lexer.switch_streams (&isInFile, &std::cout);
    msgc_glob.lexer.yyrestart (&isInFile);
    msgc_glob.lexer.resetInputDescription(inputFile->getFullName());
    msgc_glob.lexer.resetLineNos();
    
    // handle cOutDir (.c and .h files) output
    if (!msgc_glob.cOutDir.empty()) 
      {
	NativeFileName hFile = *inputFile; hFile.addExtension ("h");
	NativeFileName cFile = *inputFile; cFile.addExtension ("c");
	hFile.setDirectory (msgc_glob.cOutDir);
	cFile.setDirectory (msgc_glob.cOutDir);
    
	// open up the hfile for write
	msgc_glob.osHFile_p = new ofstream(hFile.getFullName().c_str());
	if (!*msgc_glob.osHFile_p)
	  throw msgc_exception("Could not open file "+hFile.getFullName()+" for write.");

	// open up the cfile for write
	msgc_glob.osCFile_p = new ofstream(cFile.getFullName().c_str());
	if (!*msgc_glob.osCFile_p)
	  throw msgc_exception("Could not open file "+cFile.getFullName()+" for write.");
	
	*msgc_glob.osHFile_p
	  << "/****************************************************************\n"
	  << "* AUTOGENERATED FILE (" << hFile.getFileName() << ") from (" << inputFile->getFileName() <<")\n"
	  << "*  -- DO NOT EDIT --\n"
	  << "****************************************************************/\n"
	  << "#ifndef _" << inputFile->getBase()+"_"+inputFile->getExtension() << "_H_\n"
	  << "#define _" << inputFile->getBase()+"_"+inputFile->getExtension() << "_H_\n"
	  << "#include <synctype.h>\n"
	  << "#include <mdat.h>\n"
	  << '\n';
	
	*msgc_glob.osCFile_p
	  << "/****************************************************************\n"
	  << "* AUTOGENERATED FILE (" << cFile.getFileName() << ") from (" << inputFile->getFileName() <<")\n"
	  << "*  -- DO NOT EDIT --\n"
	  << "****************************************************************/\n"
	  << "#include <synctype.h>\n"
	  << "#include <cmuser.h> /* for CM_SOCKET in ms_error.h */\n"
	  << "#include <ms_error.h> /* for MS_MESSAGE_ID_PARSE_ERROR */\n"
	  << "#include <ms_list.h>\n"
	  << "#include <ms_memor.h>\n"
	  << "#include <ms_toks.h>\n"
	  << "#include <synctype.h>\n"
	  << "#include <stdarg.h>\n"
	  << "#include <stdio.h>\n"
	  << "#include <stdlib.h> /* for malloc*/\n"
	  << "#include <snbmsg.h> /* for msg_print */\n"
	  << "#include <snbmsgno.h>\n"
	  << "#include <string.h> /* for strncpy */\n"
	  << "#include <" << hFile.getFileName() << ">\n"
	  << '\n';
      }

    // handle cxxOutDir (.cpp and .hpp files) output
    if (!msgc_glob.cxxOutDir.empty()) 
      {
	NativeFileName hFile = *inputFile; hFile.addExtension ("h");
	NativeFileName hppFile = *inputFile; hppFile.addExtension ("hpp");
	NativeFileName cppFile = *inputFile; cppFile.addExtension ("cpp");
	hppFile.setDirectory (msgc_glob.cxxOutDir);
	cppFile.setDirectory (msgc_glob.cxxOutDir);
    
	// open up the hfile for write
	msgc_glob.osHPPFile_p = new ofstream(hppFile.getFullName().c_str());
	if (!*msgc_glob.osHPPFile_p)
	  throw msgc_exception("Could not open file "+hppFile.getFullName()+" for write.");

	// open up the cfile for write
	msgc_glob.osCPPFile_p = new ofstream(cppFile.getFullName().c_str());
	if (!*msgc_glob.osCPPFile_p)
	  throw msgc_exception("Could not open file "+cppFile.getFullName()+" for write.");
	
	*msgc_glob.osHPPFile_p
	  << "/****************************************************************\n"
	  << "* AUTOGENERATED FILE (" << hppFile.getFileName() << ") from (" << inputFile->getFileName() <<")\n"
	  << "*  -- DO NOT EDIT --\n"
	  << "****************************************************************/\n"
	  << "#ifndef _" << inputFile->getBase()+"_"+inputFile->getExtension() << "_HPP_\n"
	  << "#define _" << inputFile->getBase()+"_"+inputFile->getExtension() << "_HPP_\n"
	  << "#include <synctype.h>\n"
	  << "#include <mdatstrm.hpp>\n"
	  << "#include <mdatsvc.hpp>\n"
	  << "#include <mdatcli.hpp>\n"
	  << "#include <list>\n"
	  << "#include <vector>\n"
//	  << "#include <" << hFile.getFileName() << ">\n"
	  << '\n';
	
	*msgc_glob.osCPPFile_p
	  << "/****************************************************************\n"
	  << "* AUTOGENERATED FILE (" << cppFile.getFileName() << ") from (" << inputFile->getFileName() <<")\n"
	  << "*  -- DO NOT EDIT --\n"
	  << "****************************************************************/\n"
          << "#ifdef _WIN32\n"
          << "#pragma warning(disable:4786)\n"
          << "#endif\n"
	  << "#define " << msgc_glob.inFileGuardNameBase << "_CPP_\n"
	  << "#include <synctype.h>\n"
	  << "#include <cmuser.h> /* for CM_SOCKET in ms_error.h */\n"
	  << "#include <ms_error.h> /* for MS_MESSAGE_ID_PARSE_ERROR */\n"
	  << "#include <ms_list.h>\n"
	  << "#include <ms_memor.h>\n"
	  << "#include <synctype.h>\n"
	  << "#include <stdarg.h>\n"
	  << "#include <stdio.h>\n"
	  << "#include <stdlib.h> /* for malloc*/\n"
	  << "#include <snbmsg.h> /* for msg_print */\n"
	  << "#include <snbmsgno.h>\n"
	  << "#include <string.h> /* for strncpy */\n"
	  << "#include \"" << hppFile.getFileName() << "\"\n"
	  << "#include <mdatsft.hpp> /* for MDatSvcFuncP...<> */\n"
	  << '\n';
      }
    
    // handle jOutDir (.list file for .java files) output
    if (!msgc_glob.jOutDir.empty()) 
      {
	NativeFileName jlistFile = *inputFile; jlistFile.addExtension ("list");
	jlistFile.setDirectory (msgc_glob.jOutDir);
    
	// open up the hfile for write
	msgc_glob.osJLISTFile_p = new ofstream(jlistFile.getFullName().c_str());
	if (!*msgc_glob.osJLISTFile_p)
	  throw msgc_exception("Could not open file "+jlistFile.getFullName()+" for write.");

      }
	
    msgc_glob.lexer.allowInclusion (InclusionInfo::INC_H);
    msgc_glob.lexer.allowInclusion (InclusionInfo::INC_CPP);
    do 
      { 
	yyparse ();
      }
    while (!isInFile);
    msgc_glob.lexer.disallowInclusion (InclusionInfo::INC_H);
    msgc_glob.lexer.disallowInclusion (InclusionInfo::INC_CPP);
/*
    if (msgc_glob.osHFile_p) {
      msgc_glob.lexer.printInclusion (*msgc_glob.osHFile_p, InclusionInfo::INC_H);
      *msgc_glob.osHFile_p << '\n';
    }
    msgc_glob.lexer.clearInclusion (InclusionInfo::INC_H);
*/
    
    if (msgc_glob.osHFile_p) {
      *msgc_glob.osHFile_p << "#endif /* _" << inputFile->getBase() << "_H_ */\n";
      delete msgc_glob.osHFile_p;
      msgc_glob.osHFile_p = 0;
    }
    if (msgc_glob.osCFile_p) {
      delete msgc_glob.osCFile_p;
      msgc_glob.osCFile_p = 0;
    }
    if (msgc_glob.osHPPFile_p) {
      *msgc_glob.osHPPFile_p 
	<< "#endif /* _" << inputFile->getBase() << "_HPP_ */\n";
      delete msgc_glob.osHPPFile_p;
      msgc_glob.osHPPFile_p = 0;
    }
    if (msgc_glob.osCPPFile_p) {
      delete msgc_glob.osCPPFile_p;
      msgc_glob.osCPPFile_p = 0;
    }
    if (msgc_glob.osJLISTFile_p) {
      for (std::vector<std::string>::iterator it = msgc_glob.javafiles.begin();
	   it != msgc_glob.javafiles.end(); ++it)
	*msgc_glob.osJLISTFile_p << *it << std::endl;
      msgc_glob.javafiles.clear();
      delete msgc_glob.osJLISTFile_p;
      msgc_glob.osJLISTFile_p = 0;
    }

  } catch (msgc_exception &e) {
    msgc_glob.lexer.printErrorLineNo (std::cerr);
    std::cerr << "msgc: Error: " << e.what() << endl;
    msgc_glob.lexer.reset ();
    return 1;
  } catch (std::exception &e) {
    msgc_glob.lexer.printErrorLineNo (std::cerr);
    std::cerr << "msgc: Fatal Error: " << e.what() << endl;
    msgc_glob.lexer.reset ();
    return 2;
  } catch (...) {
    msgc_glob.lexer.printErrorLineNo (std::cerr);
    std::cerr << "msgc: Internal error detected." << endl;
    msgc_glob.lexer.reset ();
    return 3;
  };
  
  return 0;
}

